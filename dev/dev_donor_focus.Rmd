---
title: "IATI Visualisation"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r developmenttest, include=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message=FALSE, 
  warning=FALSE,
  fig.width = 8,
  fig.asp = 0.718,
  out.width = "90%"
)
library(testthat) 
library(ggplot2)
library(dplyr)
library(treemapify)
library(sf)
library(rnaturalearth)
library(rnaturalearthdata)
library(ggrepel)
# Load already included functions
pkgload::load_all(export_all = FALSE)
```

## show_donor_ranking

```{r function-show_donor_ranking}
#' Generate Donor Ranking Visualizations with Scoring Metrics
#'
#' This function creates two types of visualizations:
#' 1. **Multi-year trajectory**: Shows donor ranking changes across multiple years
#' 2. **Single-year scoring**: Creates a lollipop plot comparing donors across three
#'    scaled metrics (0-100) with optional World Bank population/GDP weighting
#'
#' In single-year mode, the function computes:
#' - **Total USD**: All incoming commitments
#' - **Unearmarked USD**: Funds marked as "unearmarked" (case-insensitive)
#' - **USD/GDP**: Total USD divided by donor country GDP (from World Bank)
#' Each metric is scaled 0-100 across donors (min-max scaling) and ranks are computed.
#'
#' @param donor_name Character. Specific donor to highlight in the visualization.
#'   If NULL, all donors are shown in equal color. For single-year scoring, the
#'   highlighted donor appears in blue with rank labels.
#' @param top_n_display Integer. Number of top donors to display in multi-year
#'   trajectory plots (ranked by reference year total).
#' @param year Integer or vector of integers. Year(s) to analyze. If NULL, uses
#'   the latest available year. If multiple years provided, creates trajectory plot.
#' @param ctr_name Character vector. Filter for specific recipient country/countries.
#'   If NULL, includes all countries.
#' @param weight_by Character. Weighting method for multi-year trajectory:
#'   - "none": Raw USD values
#'   - "population": USD per capita
#'   - "gdp": USD per GDP
#'   - "population_gdp": USD per capita per GDP
#' @param donor_country_map Named character vector. Optional mapping from donor
#'   organization names to World Bank country names for GDP/population lookups.
#'   Format: c("donor_org" = "country_name")
#' @param wb_lang Character. Language for World Bank country names ("en", "fr", etc.).
#' @param top_n_earmarking Integer. For single-year scoring, number of top
#'   earmarking categories to display (not currently used in scoring mode).
#' @param verbose Logical. If TRUE, prints progress messages and data summaries.
#'
#' @return A ggplot2 object. The plot type depends on input parameters:
#'   - Multi-year: Ranking trajectory with connected points
#'   - Single-year: Lollipop scoring plot with three metrics (0-100 scale)
#'
#' @importFrom dplyr filter mutate select group_by summarise arrange desc
#'   left_join pull slice_head case_when if_else all_of rename
#' @importFrom tidyr pivot_longer
#' @importFrom lubridate parse_date_time year
#' @importFrom ggplot2 ggplot aes geom_point geom_segment geom_text
#'   scale_color_brewer scale_x_continuous scale_y_continuous labs theme
#'   element_text
#' @importFrom scales label_number cut_short_scale alpha
#' @importFrom unhcrthemes theme_unhcr
#' @importFrom rlang .env .data
#' @importFrom stats na.omit
#'
#' @export
#'
show_donor_ranking <- function(donor_name = NULL,
                               top_n_display = 10,
                               year = NULL,
                               ctr_name = NULL,
                               weight_by = c("none", "population", "gdp", "population_gdp"),
                               donor_country_map = NULL,
                               wb_lang = "en",
                               top_n_earmarking = 8,
                               verbose = TRUE) {
  
  # ---- Argument validation ----
  weight_by <- match.arg(weight_by)
  
  if (!is.numeric(top_n_display) || length(top_n_display) != 1 || top_n_display < 1) {
    stop("`top_n_display` must be a single integer >= 1.")
  }
  if (!is.numeric(top_n_earmarking) || length(top_n_earmarking) != 1 || top_n_earmarking < 1) {
    stop("`top_n_earmarking` must be a single integer >= 1.")
  }
  
  # ---- 1. Data preparation ----
  data_transaction <- iati::dataTransaction
  data_activity <- iati::dataActivity
  
  # Determine value column
  value_col <- if ("transaction_value_USD" %in% names(data_transaction)) {
    "transaction_value_USD"
  } else if ("transaction_value" %in% names(data_transaction)) {
    "transaction_value"
  } else {
    stop("No transaction value column found. Need 'transaction_value_USD' or 'transaction_value'.")
  }
  
  # Parse year(s)
  years_requested <- if (!is.null(year)) {
    yrs <- as.integer(year)
    yrs <- yrs[!is.na(yrs)]
    if (length(yrs) == 0) NULL else yrs
  } else {
    NULL
  }
  
  multi_year_mode <- !is.null(years_requested) && length(years_requested) > 1
  
  # ---- 2. Transaction data processing ----
  df <- data_transaction |>
    dplyr::filter(.data$transaction_type_name == "Incoming Commitment") |>
    dplyr::mutate(
      tx_date = as.Date(
        lubridate::parse_date_time(
          .data$transaction_date,
          orders = c("ymd", "Ymd", "ymd HMS", "Ymd HMS", "ymd HM", "Ymd HM", "dmy", "mdy"),
          quiet = TRUE,
          tz = "UTC"
        )
      ),
      year_tx = lubridate::year(.data$tx_date),
      tx_value = as.numeric(.data[[value_col]])
    ) |>
    dplyr::filter(!is.na(.data$year_tx), !is.na(.data$tx_value))
  
  # Join activity data
  act_cols <- intersect(c("iati_identifier", "ctr_name", "earmarking_name"), names(data_activity))
  df <- df |>
    dplyr::left_join(
      data_activity |> dplyr::select(dplyr::all_of(act_cols)),
      by = "iati_identifier"
    )
  
  # Apply recipient country filter if specified
  if (!is.null(ctr_name)) {
    if (!("ctr_name" %in% names(df))) {
      stop("ctr_name filter requested but `ctr_name` column not found in data.")
    }
    df <- df |> dplyr::filter(.data$ctr_name %in% .env$ctr_name)
  }
  
  # Determine years to analyze
  available_years <- sort(unique(df$year_tx))
  if (length(available_years) == 0) stop("No usable transactions after filtering.")
  
  if (is.null(years_requested)) {
    years_to_plot <- max(available_years, na.rm = TRUE)
    if (verbose) message("No year provided. Using latest year: ", years_to_plot)
  } else {
    missing_years <- setdiff(years_requested, available_years)
    if (length(missing_years) > 0) {
      stop("Year(s) not found in data: ", paste(missing_years, collapse = ", "))
    }
    years_to_plot <- years_requested
  }
  
  ref_year <- max(years_to_plot, na.rm = TRUE)
  
  # ---- 3. Identify top donors (for multi-year trajectory) ----
  donor_totals_ref <- df |>
    dplyr::filter(.data$year_tx == .env$ref_year) |>
    dplyr::group_by(.data$transaction_provider_org) |>
    dplyr::summarise(total_ref = sum(.data$tx_value, na.rm = TRUE), .groups = "drop")
  
  if (nrow(donor_totals_ref) == 0) {
    stop("No data for reference year: ", ref_year)
  }
  
  top_donors <- donor_totals_ref |>
    dplyr::arrange(dplyr::desc(.data$total_ref)) |>
    dplyr::slice_head(n = top_n_display) |>
    dplyr::pull(.data$transaction_provider_org) |>
    as.character()
  
  # Add user-specified donor if not already in top list
  if (!is.null(donor_name)) {
    donor_name <- as.character(donor_name)
    if (!donor_name %in% donor_totals_ref$transaction_provider_org) {
      stop("Donor '", donor_name, "' not found in data for year ", ref_year, ".")
    }
    if (!donor_name %in% top_donors) {
      top_donors <- unique(c(top_donors, donor_name))
    }
  }
  
  # Filter to selected years
  df <- df |> dplyr::filter(.data$year_tx %in% .env$years_to_plot)
  
  # ---- 4. World Bank data for GDP/population weighting ----
  wb_weights <- NULL
  if (multi_year_mode && weight_by != "none") {
    donors_all <- sort(unique(df$transaction_provider_org))
    
    # Map donors to countries
    donor_country <- if (!is.null(donor_country_map)) {
      mapped <- donor_country_map[names(donor_country_map) %in% donors_all]
      dplyr::tibble(
        transaction_provider_org = names(mapped),
        country_name = as.character(mapped)
      )
    } else {
      dplyr::tibble(
        transaction_provider_org = donors_all,
        country_name = donors_all
      )
    }
    
    # Fetch World Bank data if available
    if (requireNamespace("worldbank", quietly = TRUE)) {
      wb_countries <- worldbank::wb_country(lang = wb_lang)
      
      donor_country <- donor_country |>
        dplyr::left_join(
          wb_countries |> dplyr::select(.data$country_code, .data$country_name),
          by = "country_name"
        ) |>
        dplyr::filter(!is.na(.data$country_code))
      
      if (nrow(donor_country) > 0) {
        # Determine indicators needed based on weighting method
        indicators <- switch(weight_by,
          "population" = c("SP.POP.TOTL"),
          "gdp" = c("NY.GDP.MKTP.CD"),
          "population_gdp" = c("SP.POP.TOTL", "NY.GDP.MKTP.CD"),
          "none" = NULL
        )
        
        if (!is.null(indicators)) {
          wb_raw <- worldbank::wb_data(
            indicator = indicators,
            country = unique(donor_country$country_code),
            lang = wb_lang,
            start_date = min(years_to_plot),
            end_date = max(years_to_plot)
          )
          
          wb_weights <- wb_raw |>
            dplyr::mutate(year_wb = as.integer(.data$date)) |>
            dplyr::select(.data$country_code, .data$year_wb, dplyr::any_of(c("population" = "SP.POP.TOTL", "gdp" = "NY.GDP.MKTP.CD"))) |>
            dplyr::left_join(donor_country, by = "country_code") |>
            dplyr::filter(.data$year_wb %in% .env$years_to_plot) |>
            dplyr::select(.data$transaction_provider_org, .data$year_wb, dplyr::any_of(c("population", "gdp")))
        }
      }
    } else if (verbose) {
      message("Package 'worldbank' not installed. GDP/population weighting unavailable.")
    }
  }
  
  # ---- 5. Multi-year trajectory plot ----
  if (multi_year_mode) {
    return(create_multi_year_plot(
      df = df,
      years_to_plot = years_to_plot,
      ref_year = ref_year,
      top_donors = top_donors,
      donor_name = donor_name,
      ctr_name = ctr_name,
      weight_by = weight_by,
      wb_weights = wb_weights,
      top_n_display = top_n_display
    ))
  }
  
  # ---- 6. Single-year scoring plot ----
  year_single <- years_to_plot[[1]]
  
  if (!("earmarking_name" %in% names(df))) {
    stop("Single-year scoring requires `earmarking_name` column in iati::dataActivity.")
  }
  
  # Filter to single year
  df_y <- df |> dplyr::filter(.data$year_tx == .env$year_single)
  
  # Helper function to identify unearmarked funds
  is_unearmarked <- function(x) {
    if (is.null(x)) return(rep(FALSE, length(x)))
    grepl("un.?earmark", x, ignore.case = TRUE)
  }
  
  # Calculate donor metrics
  donor_metrics <- df_y |>
    dplyr::group_by(.data$transaction_provider_org) |>
    dplyr::summarise(
      total_usd = sum(.data$tx_value, na.rm = TRUE),
      unearmarked_usd = sum(dplyr::if_else(is_unearmarked(.data$earmarking_name), .data$tx_value, 0), na.rm = TRUE),
      .groups = "drop"
    )
  
  # Add GDP data if available
  if (!is.null(wb_weights)) {
    donor_metrics <- donor_metrics |>
      dplyr::left_join(
        wb_weights |>
          dplyr::filter(.data$year_wb == .env$year_single) |>
          dplyr::select(.data$transaction_provider_org, .data$gdp),
        by = "transaction_provider_org"
      )
  } else {
    donor_metrics <- donor_metrics |> dplyr::mutate(gdp = NA_real_)
  }
  
  donor_metrics <- donor_metrics |>
    dplyr::mutate(
      usd_per_gdp = ifelse(!is.na(.data$gdp) & .data$gdp > 0, .data$total_usd / .data$gdp, NA_real_)
    )
  
    # ---- 7. Scoring and ranking ----
    # Min-max scaling helper
    minmax_score <- function(v) {
      if (all(is.na(v))) return(rep(NA_real_, length(v)))
      vv <- v
      rng <- range(vv, na.rm = TRUE)
      if (rng[1] == rng[2]) {
        return(ifelse(is.na(vv), NA_real_, 100))  # All equal -> max score
      }
      100 * (vv - rng[1]) / (rng[2] - rng[1])
    }
    
    # Determine which metrics to include
    include_gdp <- sum(!is.na(donor_metrics$usd_per_gdp)) > 1  # Need at least 2 donors with GDP data
    
    # Compute scores and ranks
    scored <- donor_metrics |>
      dplyr::mutate(
        score_total = minmax_score(.data$total_usd),
        score_unearmarked = minmax_score(.data$unearmarked_usd),
        rk_total = dplyr::if_else(
          is.na(.data$total_usd),
          NA_integer_,
          dplyr::min_rank(dplyr::desc(.data$total_usd))
        ),
        rk_unearmarked = dplyr::if_else(
          is.na(.data$unearmarked_usd),
          NA_integer_,
          dplyr::min_rank(dplyr::desc(.data$unearmarked_usd))
        )
      )
    
    # Conditionally add GDP scoring
    if (include_gdp) {
      scored <- scored |>
        dplyr::mutate(
          score_usd_gdp = minmax_score(.data$usd_per_gdp),
          rk_usd_gdp = dplyr::if_else(
            is.na(.data$usd_per_gdp),
            NA_integer_,
            dplyr::min_rank(dplyr::desc(.data$usd_per_gdp))
          )
        )
      if (verbose) {
        message("Including USD/GDP metric (", sum(!is.na(scored$usd_per_gdp)), 
                " donors have GDP data)")
      }
    } else {
      if (verbose) {
        message("Excluding USD/GDP metric - insufficient data (only ", 
                sum(!is.na(donor_metrics$usd_per_gdp)), 
                " donors have GDP data)")
      }
    }
  
  # Prepare column selection based on available metrics
  score_cols <- c("score_total", "score_unearmarked")
  rank_cols <- c("rk_total", "rk_unearmarked")
  metric_labels <- c("Total USD", "Unearmarked USD")
  metric_levels <- c("total", "unearmarked")
  
  if (include_gdp) {
    score_cols <- c(score_cols, "score_usd_gdp")
    rank_cols <- c(rank_cols, "rk_usd_gdp")
    metric_labels <- c(metric_labels, "USD/GDP")
    metric_levels <- c(metric_levels, "usd_gdp")
  }
  
  # Reshape for plotting
  plot_df <- scored |>
    tidyr::pivot_longer(
      cols = dplyr::all_of(c(score_cols, rank_cols)),
      names_to = c(".value", "metric"),
      names_pattern = "(score|rk)_(total|unearmarked|usd_gdp)"
    ) |>
    dplyr::mutate(
      metric = factor(.data$metric,
        levels = metric_levels,
        labels = metric_labels
      )
    )
  # Count donors per metric for denominator in rank labels
  N_total <- sum(!is.na(scored$total_usd))
  N_unearmarked <- sum(!is.na(scored$unearmarked_usd))
  N_usd_gdp <- if (include_gdp) sum(!is.na(scored$usd_per_gdp)) else 0
  
  # Add rank labels
  plot_df <- plot_df |>
    dplyr::mutate(
      rk_lab = dplyr::case_when(
        .data$metric == "Total USD" & !is.na(.data$rk) ~ paste0("Rk ", .data$rk, "/", N_total),
        .data$metric == "Unearmarked USD" & !is.na(.data$rk) ~ paste0("Rk ", .data$rk, "/", N_unearmarked),
        .data$metric == "USD/GDP" & !is.na(.data$rk) & include_gdp ~ paste0("Rk ", .data$rk, "/", N_usd_gdp),
        TRUE ~ NA_character_
      )
    )


  # ---- 8. Create single-year scoring plot ----
  return(create_single_year_plot(
    plot_df = plot_df,
    donor_name = donor_name,
    year_single = year_single,
    verbose = verbose,
    donor_metrics = donor_metrics,
    scored = scored
  ))
}

# Helper function for multi-year trajectory plot
create_multi_year_plot <- function(df, years_to_plot, ref_year, top_donors, donor_name,
                                   ctr_name, weight_by, wb_weights, top_n_display) {
  
  # Aggregate by donor and year
  df_year <- df |>
    dplyr::filter(.data$transaction_provider_org %in% .env$top_donors) |>
    dplyr::group_by(.data$transaction_provider_org, .data$year_tx) |>
    dplyr::summarise(total_funding = sum(.data$tx_value, na.rm = TRUE), .groups = "drop")
  
  # Apply weighting if requested
  if (weight_by != "none" && !is.null(wb_weights)) {
    df_year <- df_year |>
      dplyr::left_join(
        wb_weights |> dplyr::rename(year_tx = .data$year_wb),
        by = c("transaction_provider_org", "year_tx")
      ) |>
      dplyr::filter(!(is.na(.data$population) & weight_by %in% c("population", "population_gdp")),
                    !(is.na(.data$gdp) & weight_by %in% c("gdp", "population_gdp"))) |>
      dplyr::mutate(
        metric_value = compute_weighted_metric(
          .data$total_funding,
          .data$population,
          .data$gdp,
          weight_by
        )
      )
  } else {
    df_year <- df_year |> dplyr::mutate(metric_value = .data$total_funding)
  }
  
  # Order donors by reference year performance
  ref_order <- df_year |>
    dplyr::filter(.data$year_tx == .env$ref_year) |>
    dplyr::arrange(.data$metric_value) |>
    dplyr::pull(.data$transaction_provider_org) |>
    as.character()
  
  df_year <- df_year |>
    dplyr::mutate(
      donor = factor(.data$transaction_provider_org, levels = ref_order),
      year_f = factor(.data$year_tx, levels = sort(unique(.data$year_tx))),
      highlight = if (is.null(donor_name)) {
        "No"
      } else {
        ifelse(.data$transaction_provider_org == donor_name, "Yes", "No")
      }
    )
  
  # Calculate ranges for connecting lines
  df_ranges <- df_year |>
    dplyr::group_by(.data$donor) |>
    dplyr::summarise(
      xmin = min(.data$metric_value, na.rm = TRUE),
      xmax = max(.data$metric_value, na.rm = TRUE),
      .groups = "drop"
    )
  
  # Prepare titles
  title <- paste0(
    "Donor ranking trajectory (", min(years_to_plot), "–", max(years_to_plot), ")",
    if (!is.null(ctr_name)) paste0(" — ", paste(ctr_name, collapse = ", ")) else ""
  )
  
  subtitle <- paste0(
    "Top ", top_n_display, " donors (selected by ", ref_year, "). ",
    "Points are annual values; color indicates year. ",
    if (weight_by != "none") paste0("Weighted by ", weight_by, ". ")
  )
  
  # Create plot
  p <- ggplot2::ggplot(df_year, ggplot2::aes(y = .data$donor, x = .data$metric_value)) +
    ggplot2::geom_segment(
      data = df_ranges,
      ggplot2::aes(y = .data$donor, yend = .data$donor, x = .data$xmin, xend = .data$xmax),
      linewidth = 1,
      color = "#B9C2CB"
    ) +
    ggplot2::geom_point(ggplot2::aes(color = .data$year_f), size = 3.8) +
    ggplot2::scale_color_brewer(palette = "Set1", name = "Year") +
    ggplot2::scale_x_continuous(
      labels = scales::label_number(scale_cut = scales::cut_short_scale())
    ) +
    unhcrthemes::theme_unhcr(
      grid = "X",
      axis = "Y",
      axis_title = FALSE,
      font_size = 20
    ) +
    ggplot2::labs(
      title = title,
      subtitle = subtitle,
      x = "Funding amount",
      y = NULL,
      caption = "Source: Data published by UNHCR as part of the International Aid Transparency Initiative (IATI)"
    )
  
  # Highlight specific donor if requested
  if (!is.null(donor_name)) {
    p <- p + ggplot2::geom_point(
      data = dplyr::filter(df_year, .data$highlight == "Yes"),
      ggplot2::aes(color = .data$year_f),
      size = 5.2
    )
  }
  
  return(p)
}

# Helper function for weighted metric calculation
compute_weighted_metric <- function(total, population, gdp, method) {
  switch(method,
    "population" = total / population,
    "gdp" = total / gdp,
    "population_gdp" = total / (population * gdp),
    total  # "none"
  )
}

# Helper function for single-year scoring plot
create_single_year_plot <- function(plot_df, donor_name, year_single, verbose,
                                    donor_metrics, scored) {
  
  # Check if we have a donor to highlight
  has_focus <- !is.null(donor_name) && donor_name %in% plot_df$transaction_provider_org
  
  # Split data for plotting
  if (has_focus) {
    df_focus <- plot_df |> dplyr::filter(.data$transaction_provider_org == .env$donor_name)
    df_others <- plot_df |> dplyr::filter(.data$transaction_provider_org != .env$donor_name)
  } else {
    df_focus <- NULL
    df_others <- NULL
  }
  
  # Define aesthetics
  col_all <- scales::alpha("#8E99A4", 0.35)  # Light grey, semi-transparent
  col_focus <- "#0072BC"                     # UNHCR blue
  size_all <- 3.0
  size_focus <- 4.6
  
  # Base plot
  p <- ggplot2::ggplot(mapping = ggplot2::aes(x = .data$metric, y = .data$score))
  
  if (has_focus) {
    # Plot other donors in grey
    p <- p + ggplot2::geom_point(
      data = df_others,
      color = col_all,
      size = size_all,
      position = ggplot2::position_jitter(width = 0.08, height = 0, seed = 42),
      na.rm = TRUE
    )
    
    # Plot highlighted donor in blue
    p <- p + ggplot2::geom_point(
      data = df_focus,
      color = col_focus,
      size = size_focus,
      na.rm = TRUE
    )
    
    # Add rank labels for highlighted donor
    if (requireNamespace("ggrepel", quietly = TRUE)) {
      p <- p + ggrepel::geom_text_repel(
        data = dplyr::filter(df_focus, !is.na(.data$rk_lab)),
        ggplot2::aes(label = .data$rk_lab),
        color = "black",
        size = 10,
        direction = "y",
        box.padding = 0.15,
        point.padding = 0.25,
        segment.color = "grey60",
        segment.size = 0.3,
        min.segment.length = 0,
        nudge_y = 4.5,
        na.rm = TRUE
      )
    } else {
      p <- p + ggplot2::geom_text(
        data = dplyr::filter(df_focus, !is.na(.data$rk_lab)),
        ggplot2::aes(label = .data$rk_lab),
        color = col_focus,
        size = 4.0,
        vjust = -0.7,
        na.rm = TRUE
      )
    }
  } else {
    # Plot all donors in grey
    p <- p + ggplot2::geom_point(
      data = plot_df,
      color = col_all,
      size = size_all,
      position = ggplot2::position_jitter(width = 0.08, height = 0, seed = 42),
      na.rm = TRUE
    )
  }
  
  # Add plot elements
  p <- p +
    ggplot2::scale_y_continuous(
      limits = c(0, 100),
      breaks = seq(0, 100, by = 20)
    ) +
    ggplot2::labs(
      title = paste0(
        "Donor scoring (", year_single, ") — ",
        if (has_focus) donor_name else "All donors"
      ),
      subtitle = paste(
        "Scores: min–max across donors per metric.",
        if (has_focus) "Blue = selected donor; label shows rank within each metric."
      ),
      x = "Score type",
      y = "Score (0–100)",
      caption = "Source: Data published by UNHCR as part of the International Aid Transparency Initiative (IATI)"
    ) +
    unhcrthemes::theme_unhcr(
      grid = "Y",
      axis = "X",
      axis_title = FALSE,
      font_size = 20
    ) +
    ggplot2::theme(legend.position = "none")
  
  # Print verbose output if requested
  if (verbose) {
    message("Single-year scoring plot created for year: ", year_single)
    message("Total donors included: ", nrow(donor_metrics))
    message("Donors with GDP data: ", sum(!is.na(scored$usd_per_gdp)))
    if (!has_focus) {
      message("Tip: Use donor_name parameter to highlight a specific donor.")
    }
  }
  
  return(p)
}
```

```{r example-show_donor_ranking, message=FALSE, warning=FALSE, fig.retina = 2, fig.width = 8, fig.asp = 0.818, fig.align = "center",  out.width = "90%"}
#' # Single-year scoring for all donors
#' show_donor_ranking(year = 2023)
#'
#' # Highlight specific donor in single-year scoring
#' show_donor_ranking(donor_name = "USA", year = 2023)
#'
#' # Multi-year trajectory for top 15 donors
#' show_donor_ranking(year = 2020:2023, top_n_display = 15)
#'
#' # With country filtering
#' show_donor_ranking(
#'   year = 2023,
#'   ctr_name = c("Ukraine", "Syria"),
#'   donor_name = "Germany"
#' )
#'
#' # With GDP weighting in multi-year mode
#' show_donor_ranking(
#'   year = 2020:2022,
#'   weight_by = "gdp",
#'   top_n_display = 10
#' )
# Example usage:
show_donor_ranking(  
   year = 2025,
   top_n_display = 20 )

show_donor_ranking(
  donor_name = "Private donors",
  year = c(2023,2024,2025),
  top_n_display = 10
)

show_donor_ranking(   
  donor_name = "Private donors", 
   year = 2023,
   top_n_display = 10 )


```

```{r tests-show_donor_ranking}
test_that("show_donor_ranking works", {
  
  # Test with a specific donor and year
  p_rank1 <- show_donor_ranking( donor_name = "Private donors", 
    year = 2023,
    top_n_display = 10
  )
  expect_true(ggplot2::is_ggplot(p_rank1))
})
```


## plot_donor_regional_focus_treemap

```{r function-plot_donor_regional_focus_treemap}
#' Plot donor regional and programme focus as a treemap
#'
#' @description
#' This function generates a treemap visualization showing a donor's funding
#' allocation across UNHCR regions and within those regions, by programme.
#' The size of each treemap tile can represent either the absolute funding
#' amount or the share of the donor's total funding for that programme within a region.
#'
#' @param donor_name Character. The name of the donor to analyze.
#' @param year Numeric or integer vector. Year(s) to filter the data.
#' @param measure_type Character. One of "total_amount_usd" (default) or "share".
#'   - "total_amount_usd": Tile size represents the absolute USD amount.
#'   - "share": Tile size represents the share of the donor's total funding
#'     that goes to a specific programme within a specific UNHCR region.
#' @param label_font_size Numeric. Base font size for treemap labels.
#'
#' @return A ggplot object representing the treemap.
#' @import ggplot2
#' @import dplyr
#' @import scales
#' @import treemapify
#' @import unhcrthemes
#'
#' @export
plot_donor_regional_focus_treemap <- function(donor_name,
                                              year = NULL ) {

 
  # ---- 1) Get IATI data ----
  df <- iati::dataTransaction |>
    dplyr::left_join(iati::dataActivity, by = "iati_identifier") |>
    dplyr::filter(
      transaction_type_name == "Incoming Commitment"
    )

  # Filtering by year
  if (!is.null(year)) {
    df <- df |> dplyr::filter(year %in% .env$year)
  }

  if (nrow(df) == 0) {
    stop("No data found for the selected donor and year(s).")
  }
  
  # Ensure necessary columns are not NA
  df <- df |>
    dplyr::filter(!is.na(unhcr_region), !is.na(activity_name), !is.na(transaction_value_USD))

  if (nrow(df) == 0) {
    stop("No data remaining after filtering out NA values for region, programme, or funding.")
  }

  # ---- 2) Aggregate data for treemap ----
  treemap_data <- df |>
    dplyr::group_by(unhcr_region, activity_name) |>
    dplyr::summarise(
      total_funding = sum(transaction_value_USD, na.rm = TRUE),
      ## total funded by the donor - ,   transaction_provider_org == donor_name
      
      .groups = "drop"
    ) |>
    dplyr::ungroup() |> 
    dplyr::left_join(
      df |>
        dplyr::filter( transaction_provider_org == donor_name) |>
        dplyr::group_by(activity_name) |>
        dplyr::summarise(
            total_funding_donor = sum(transaction_value_USD, na.rm = TRUE),
      .groups = "drop")|>    dplyr::ungroup(),
    by= c("activity_name")) |>
    dplyr::mutate( 
      share = total_funding_donor/ total_funding  ,
      label_text =  paste0(activity_name, " - ", 
                           scales::label_number(accuracy = 0.1, scale_cut = scales::cut_short_scale())(total_funding_donor), 
                           "$ (",
                           scales::label_percent(accuracy = 0.1)(share), 
                           ")"))|>
    dplyr::filter( !(is.na(total_funding_donor))  )
  
  # Calculate overall donor total for 'share' measure type
  donor_total_overall <- sum(treemap_data$total_funding_donor, na.rm = TRUE)



  if (nrow(treemap_data) == 0) {
    stop("No valid funding data to plot after aggregation and filtering for value_to_map.")
  }
  
  # Define colors for regions (first level of treemap)
  region_colors <- unhcrthemes::unhcr_pal(n = length(unique(treemap_data$unhcr_region)), name = "pal_unhcr")
  
  # ---- 3) Plotting ----
  p <- ggplot2::ggplot(treemap_data,
                        ggplot2::aes(area = total_funding_donor,
                                     fill = unhcr_region,
                                     subgroup = unhcr_region,
                                     label = label_text)) +
    treemapify::geom_treemap() +
    treemapify::geom_treemap_subgroup_border(colour = "white", size = 3) +
      # Use multiple text layers with different placements
      treemapify::geom_treemap_subgroup_text(place = "centre",
                                             grow = T, 
                                             alpha = 0.5, 
                                             colour ="black", 
                                             fontface = "italic", 
                                             min.size = 0) +
    
      treemapify::geom_treemap_text(colour = "white", 
                                    place = "topleft", 
                                    reflow = T) + 
     # treemapify::geom_treemap_subgroup_text(
     #    place = "centre", 
     #    grow = TRUE,
     #    alpha = 0.5, 
     #    colour = "black",
     #    fontface = "bold", 
     #    min.size = 0
     #  ) +
  
      # treemapify::geom_treemap_text(
      #   colour = "white",
      #   place = "topleft",      # Different placement for first label
      #   size = label_font_size * 0.9,  # Slightly smaller for corner placement
      #   family = "Lato",
      #   grow = FALSE,           # Don't let it grow
      #   padding.x = grid::unit(2, "mm"),  # Add padding
      #   padding.y = grid::unit(2, "mm"),
      #   reflow = TRUE,          # Reflow text if too long
      #   min.size = 4            # Minimum font size
      # ) +
      # # Optional: Add secondary text with smaller size for additional info
      # treemapify::geom_treemap_text(
      #   ggplot2::aes(label = secondary_label),  # Create a secondary label column
      #   colour = "white",
      #   place = "bottomright",
      #   size = label_font_size * 0.7,
      #   family = "Lato",
      #   alpha = 0.8,
      #   grow = FALSE,
      #   min.size = 2
      # ) +
    ggplot2::scale_fill_manual(values = region_colors) +
    unhcrthemes::theme_unhcr(void = TRUE,
                             legend = FALSE, 
                             font_size = 20) +
    ggplot2::labs(
      title = paste("Portfolio of ", donor_name, " |", paste(year), ""),

      caption = "Source: Data published by UNHCR as part of the International Aid Transparency Initiative (IATI) - Includes Total Funding (Share of Donor's Funding within this activity)"
    )

  return(p)
}
```

```{r example-plot_donor_regional_focus_treemap, message=FALSE, warning=FALSE, fig.retina = 2, fig.width = 10, fig.asp = 0.7, fig.align = "center", out.width = "90%"}
# Example usage:
plot_donor_regional_focus_treemap(
  donor_name = "Private donors",
  year =  2025 
)
 
```

```{r tests-plot_donor_regional_focus_treemap}
test_that("plot_donor_regional_focus_treemap works", {
  # Test with a specific donor and year, checking for ggplot object
  p_treemap <- plot_donor_regional_focus_treemap(
          donor_name = "Private donors",
          year =  2025 
        )
  expect_true(ggplot2::is_ggplot(p_treemap))
  
})
```


## plot_donor_location_map

```{r function-plot_donor_location_map}
#' Plot donor funding on a world map with proportional symbols
#'
#' @description
#' This function generates a world map showing funding locations for a given donor
#' and year(s). It uses proportional symbols where a white outer circle represents
#' the total funding from all donors at a location, and an inner UNHCR blue circle
#' represents the specific donor's funding at that location. The visual difference
#' between the two circles provides insight into the donor's contribution share.
#' Top locations by donor funding are highlighted with ggrepel labels.
#' The map uses a Bertin 1951-like projection (Equal Earth) for good world generalization.
#'
#' @param donor_name Character. The name of the donor to filter by.
#' @param year Numeric or integer vector. Year(s) to filter the transaction data.
#' @param top_n_locations Integer. Number of top locations (by donor funding)
#'   to label using `ggrepel`. Defaults to 5.
#' @param max_symbol_size Numeric. Maximum size for the proportional symbols.
#'   Adjust based on data range and desired visual effect. Defaults to 15.
#'
#' @return A ggplot object representing the world map.
#' @import ggplot2
#' @import dplyr
#' @import sf
#' @import rnaturalearth
#' @import rnaturalearthdata
#' @import ggrepel
#' @import scales
#' @import unhcrthemes
#'
#' @export
plot_donor_location_map <- function(donor_name,
                                    year = NULL,
                                    top_n_locations = 5,
                                    max_symbol_size = 15) {

  # ---- 0) Basic checks ----
  if (!is.numeric(top_n_locations) || length(top_n_locations) != 1 || top_n_locations < 0) {
    stop("`top_n_locations` must be a single non-negative integer.")
  }
  if (!is.numeric(max_symbol_size) || length(max_symbol_size) != 1 || max_symbol_size <= 0) {
    stop("`max_symbol_size` must be a single positive numeric value.")
  }

  # ---- 1) Load map data ----
  # Using Bertin
  target_crs <- "+proj=bertin1953" 
  
  world_sf <- rnaturalearth::ne_countries(scale = "medium", returnclass = "sf") |>
    dplyr::filter( !(admin == "Antarctica")) |>
    sf::st_transform(crs = target_crs)

  # ---- 2) Prepare IATI data ----
  # Filter transactions for the specified donor and year(s)
  filtered_transactions <- iati::dataTransaction |>
    dplyr::left_join(iati::dataActivity, by = "iati_identifier") |>
    dplyr::filter(
      transaction_type_name == "Incoming Commitment",
      transaction_provider_org == donor_name
    ) 

  if (!is.null(year)) {
    filtered_transactions <- filtered_transactions |> dplyr::filter(year %in% .env$year)
  }

  if (nrow(filtered_transactions) == 0) {
    stop("No transaction data found for the specified donor and year(s).")
  }
  
  # Get all transactions for total funding calculation at locations
  all_transactions <- iati::dataTransaction |>
    dplyr::left_join(iati::dataActivity, by = "iati_identifier") |>
    dplyr::filter(
      transaction_type_name == "Incoming Commitment",
      transaction_provider_org == donor_name
    ) 
  
  if (!is.null(year)) {
    all_transactions <- all_transactions |> dplyr::filter(year %in% .env$year)
  }

  # Join with location data and aggregate funding using iati_identifier
  # location_type = c("UNHCR Headquarters", "UNHCR Regional Bureau", 
  # "UNHCR Country Office", "UNHCR Chargé de Mission", "UNHCR Multi-country Office", 
  # "UNHCR National Office", "UNHCR Field Office", "UNHCR Field Unit", 
  # "UNHCR Sub-Office", "UNHCR Regional Office", "UNHCR Liaison Office", 
  # "UNHCR Deputy Director Office", "UNHCR Branch Office", "UNHCR Multi-Country Office", 
  # "Global Hub / Service Center", "UNHCR Office of Special Coordinator", 
  # "UNHCR Planned Office")

  mainLocation <- iati::dataLocation |> 
    # Group and collapse multiple values
    dplyr::group_by(iati_identifier, location_type) |> 
    dplyr::summarize(
      location_ref = paste(unique(location_ref), collapse = "; "),
      .groups = "drop"
    ) |> 
    
    # Then pivot
    tidyr::pivot_wider(
      id_cols = iati_identifier,
      names_from = location_type,
      values_from = location_ref
    ) |> 
    janitor::clean_names() |>
    
    # Apply business logic - extract first value if there are multiple
    dplyr::mutate(
      across(where(is.character), 
             ~ifelse(is.na(.) | . == "", NA_character_, .)) ) |>
    
    dplyr::mutate(
      main_location_ref = dplyr::case_when(
        # Extract first HQ if exists
        !is.na(unhcr_headquarters)  ~ "CHEP000332",
        
        # Extract first bureau if exists
        !is.na(unhcr_regional_bureau)  ~ unhcr_regional_bureau,
        
        ## Regional bureau
        is.na(unhcr_headquarters) & 
          is.na(unhcr_regional_bureau) &
          is.na(unhcr_country_office) &
          is.na(unhcr_regional_bureau)  &
        !is.na(unhcr_regional_office)  ~ unhcr_regional_office,
        
        # Extract first MCO if exists
        !is.na(unhcr_multi_country_office)  ~ unhcr_multi_country_office,
        
        ## Branch office
        is.na(unhcr_headquarters) & 
          is.na(unhcr_regional_bureau) &
          is.na(unhcr_country_office) &
          is.na(unhcr_national_office) &
          !is.na(unhcr_branch_office)  ~ unhcr_branch_office,
        
        ## National office
        is.na(unhcr_headquarters) & 
          is.na(unhcr_regional_bureau) &
          is.na(unhcr_country_office) &
          is.na(unhcr_branch_office) &
          !is.na(unhcr_national_office)  ~ unhcr_national_office,
        
        ## Liaison office
        is.na(unhcr_headquarters) & 
          is.na(unhcr_regional_bureau) &
          is.na(unhcr_country_office) &
          is.na(unhcr_branch_office) &
          is.na(unhcr_national_office)&
          !is.na(unhcr_liaison_office)   ~ unhcr_liaison_office,
        
        ## Charge mission
        is.na(unhcr_headquarters) & 
          is.na(unhcr_regional_bureau) &
          is.na(unhcr_country_office) &
          is.na(unhcr_branch_office) &
          is.na(unhcr_national_office) &
          is.na(unhcr_liaison_office)  &
          !is.na(unhcr_charge_de_mission)   ~ unhcr_charge_de_mission,
        
        # Default to first country office
        .default = unhcr_country_office
      )
    ) |>
    ## Manual clean
    dplyr::mutate(
      main_location_ref = dplyr::case_when(
        main_location_ref == "AGOp000019; MOZp000256"  ~ "MOZp000256",
        main_location_ref == "MWIp000238; ZMBp000385" ~ "ZMBp000385", 
        main_location_ref == "ZWEp000389; MWIp000238; ZMBp000385" ~ "ZMBp000385", 
        main_location_ref == "CZEP000102; POLP000277" ~ "POLP000277",
        main_location_ref == "BLRP000035; RUSp000290" ~ "RUSp000290",
        main_location_ref == "MDAP000254; BLRP000035" ~ "HUNP000749",
        # Default  
        .default = main_location_ref
      )
    ) |> 
    select(main_location_ref, iati_identifier) |>
      dplyr::left_join(iati::dataLocation |>  
                         dplyr::select( location_ref, 
                                        location_lat, location_long ) |> 
                         distinct() ,
                    ## retain a single location per activity_name aka the office the most important   
                    by = c( "main_location_ref" = "location_ref") ) |>
    dplyr::rename("lat"="location_lat", "lon"="location_long")
  
  # Aggregate all donor funding per location
  all_donor_locations_funding <- all_transactions |>
    dplyr::left_join(mainLocation |> 
                       dplyr::select(main_location_ref, iati_identifier), by = "iati_identifier") |>
    dplyr::filter( !is.na(transaction_value_USD)) |>
    dplyr::filter(! is.na(main_location_ref)) |>
    dplyr::group_by(main_location_ref) |>
    dplyr::summarise(
      total_funding_all_donors = sum(transaction_value_USD, na.rm = TRUE),
      .groups = "drop"
    )  
   # sf::st_as_sf(coords = c("lon", "lat"), crs = 4326) # WGS 84
  
  # Aggregate specific donor funding per location
  donor_locations_funding <- filtered_transactions |>
    dplyr::left_join(mainLocation |>
                       dplyr::select(main_location_ref, iati_identifier), by = "iati_identifier") |>
    dplyr::filter( !is.na(transaction_value_USD)) |>
    dplyr::group_by(main_location_ref) |>
    dplyr::summarise(
      total_funding_donor = sum(transaction_value_USD, na.rm = TRUE),
      .groups = "drop"
    )  

  if (nrow(donor_locations_funding) == 0) {
    stop("No valid location data with coordinates and funding found for the specified donor.")
  }

  # Join aggregated data
  map_data <- all_donor_locations_funding |>
    dplyr::full_join(
      donor_locations_funding, #|> sf::st_drop_geometry(), # drop geometry to avoid join issues, re-add later
      by = c( "main_location_ref")
    ) |>
    dplyr::left_join(mainLocation |>
                       dplyr::select(main_location_ref, lat, lon) |>
                       unique(), by = "main_location_ref") |>
    dplyr::filter(! (is.na(main_location_ref))) |>
     sf::st_as_sf(coords = c("lon", "lat"), crs = 4326) |> # WGS 84
    dplyr::mutate(
      total_funding_donor = tidyr::replace_na(total_funding_donor, 0),
      # Add geometry back from all_donor_locations_funding
      geometry = geometry # This ensures sf object maintains its geometry
    ) |>
    # Transform to target CRS after full_join
    sf::st_transform(crs = target_crs)

  # Filter out locations with no funding from either (after joins and NA replacements)
  map_data <- map_data |>
    dplyr::filter(total_funding_all_donors > 0 | total_funding_donor > 0)
  
  if (nrow(map_data) == 0) {
    stop("No locations with funding data after joining and filtering.")
  }

  # Identify top locations for labeling
  top_locations_labels <- map_data |>
    dplyr::arrange(dplyr::desc(total_funding_donor)) |>
    dplyr::slice_head(n = top_n_locations) |>
    dplyr::mutate(
      label = paste0( "", scales::label_number(
    scale_cut = scales::cut_short_scale(), accuracy = 0.1)(total_funding_donor) , "")
    )

  # ---- 3) Define colors and sizes ----
  ocean_color <- "#E0F2F7" # Light blue
  country_fill_color <- "#D3D3D3" # Elegant gray
  country_border_color <- "#F0F0F0" # Very light white
  
  donor_color <- "#0072BC"
  all_donors_color <- "white"

  # ---- 4) Plotting ----
  p <- ggplot2::ggplot() +
    # Ocean background
    ggplot2::geom_sf(data = world_sf, fill = ocean_color, color = NA) + # Draw entire world as ocean
    
    # Countries
    ggplot2::geom_sf(data = world_sf, fill = country_fill_color, color = country_border_color, linewidth = 0.1) +
    
    # Proportional symbols for ALL donor funding (background circles)
    ggplot2::geom_sf(
      data = map_data |> dplyr::filter(total_funding_all_donors > 0),
      ggplot2::aes(size = total_funding_all_donors),
      shape = 21, fill = all_donors_color, color = "black", stroke = 0.5,
      alpha = 0.7,
      show.legend = "point"
    ) +
    
    # Proportional symbols for specific donor funding (foreground circles)
    ggplot2::geom_sf(
      data = map_data |> dplyr::filter(total_funding_donor > 0),
      ggplot2::aes(size = total_funding_donor),
      shape = 21, fill = donor_color, color = donor_color, stroke = 0.5,
      alpha = 0.8,
      show.legend = "point"
    ) +
    
    # Scale for proportional symbol sizes
    ggplot2::scale_size_continuous(
      name = "Funding (USD)",
      range = c(1, max_symbol_size) 
    ) +
    
    # Labels for top locations
    ggrepel::geom_label_repel(
      data = top_locations_labels,
      ggplot2::aes(label = label, geometry = geometry),
      stat = "sf_coordinates",
      min.segment.length = 0,
      box.padding = 0.5,
      point.padding = 0.5,
      force = 1,
      size = 7,
      direction = "both",
      color = "black"
    ) +
    
    unhcrthemes::theme_unhcr(void = TRUE, 
                             legend = FALSE,
                             font_size = 20) +
    ggplot2::theme(
      panel.background = ggplot2::element_rect(fill = ocean_color, color = NA),
      plot.background = ggplot2::element_rect(fill = ocean_color, color = NA)
    ) +
    ggplot2::labs(
      title = paste("Geographic Focus for ", donor_name, "|", year),
      caption = paste0(
        # "White circle: Total funding from all donors. UNHCR blue circle: Funding from ", donor_name, ".\n",
        # "Size indicates amount. Difference in circle size shows donor's share.\n",
        "Source: Data published by UNHCR as part of the International Aid Transparency Initiative (IATI)"
      )
    )

  return(p)
}
```

```{r example-plot_donor_location_map, message=FALSE, warning=FALSE, fig.retina = 2, fig.width = 12, fig.asp = 0.6, fig.align = "center", out.width = "90%"}
# Example usage:
plot_donor_location_map(
  donor_name = "Private donors",
  year = 2025,
  top_n_locations = 5,
  max_symbol_size = 20
)
```

```{r tests-plot_donor_location_map}
test_that("plot_donor_location_map works", {
  # Test with a specific donor and year, checking for ggplot object
  p_map <- plot_donor_location_map(
    donor_name = "Private donors",
    year = 2025,
    top_n_locations = 1
  )
  expect_true(ggplot2::is_ggplot(p_map))
})
```



## show_donor_funding_over_time
    
```{r function-show_donor_funding_over_time}

#' Plot donor funding over time (bar chart)
#'
#' @description
#' This function plots the funding from a specific donor over time as a bar chart.
#' If `by` is not "global", the plot is faceted by the corresponding `by` variable.
#'
#' @param donor_name The name of the donor to plot.
#' @param year A numeric value or a vector of numeric values to filter on year.
#' @param by The category to group by. One of "global", "region", "country", "earmarking_name".
#' @param programme_lab A character vector corresponding to the name of the programme.
#' @param iati_identifier_ops A character vector corresponding to the name of the operation.
#' @param ctr_name A character vector corresponding to the name of the country.
#' @param top_n_countries The number of top countries to show when `by = "country"`.
#'
#' @import ggplot2
#' @import dplyr
#' @import scales
#' @import unhcrthemes
#'
#' @export
show_donor_funding_over_time <- function(donor_name,
                                         year = NULL,
                                         by = "global",
                                         programme_lab = NULL,
                                         iati_identifier_ops = NULL,
                                         ctr_name = NULL,
                                         top_n_countries = 10) {

  # Basic data preparation
  df <- iati::dataTransaction |>
    dplyr::left_join(iati::dataActivity, by = "iati_identifier") |>
    dplyr::filter(
      transaction_provider_org == donor_name,
      transaction_type_name == "Incoming Commitment"
    )

  # Filtering (vector-friendly)
  if (!is.null(year)) {
    df <- df |> dplyr::filter(year %in% year)
  }
  if (!is.null(programme_lab)) {
    df <- df |> dplyr::filter(programme_lab %in% programme_lab)
  } else if (!is.null(iati_identifier_ops)) {
    df <- df |> dplyr::filter(iati_identifier_ops %in% iati_identifier_ops)
  } else if (!is.null(ctr_name)) {
    df <- df |> dplyr::filter(ctr_name %in% ctr_name)
  }

  # Ensure year is an ordered factor (nice bar ordering) - robust to char/numeric
  df <- df |>
    dplyr::mutate(
      year = suppressWarnings(as.numeric(as.character(year))),
      year = factor(year, levels = sort(unique(year), na.last = TRUE))
    )

  # Determine grouping variable (for faceting when by != global)
  facet_var <- switch(
    by,
    "global" = NULL,
    "region" = "unhcr_region",
    "country" = "ctr_name",
    "earmarking_name" = "earmarking_name",
    stop("Invalid 'by' argument. Choose from 'global', 'region', 'country', 'earmarking_name'.")
  )



  # If by == country: keep only top N countries overall (across years)
  if (identical(by, "country")) {
    top_countries <- df |>
      dplyr::group_by(ctr_name) |>
      dplyr::summarise(
        total = sum(transaction_value_USD, na.rm = TRUE),
        .groups = "drop"
      ) |>
      dplyr::slice_max(order_by = total, n = top_n_countries, with_ties = FALSE) |>
      dplyr::pull(ctr_name)

    df <- df |> dplyr::filter(ctr_name %in% top_countries)
  }

  # Drop NA levels for facet var (after any mapping above)
  if (!is.null(facet_var)) {
    df <- df |> dplyr::filter(!is.na(.data[[facet_var]]))
  }

  # Summarise
  if (is.null(facet_var)) {
    show_data <- df |>
      dplyr::group_by(year) |>
      dplyr::summarise(
        total_funding = sum(transaction_value_USD, na.rm = TRUE),
        .groups = "drop"
      )
  } else {
    show_data <- df |>
      dplyr::group_by(year, .data[[facet_var]]) |>
      dplyr::summarise(
        total_funding = sum(transaction_value_USD, na.rm = TRUE),
        .groups = "drop"
      )
  }

  # Subtitle logic (mentions top_n_countries when by == "country")
  subtitle_txt <- if (is.null(facet_var)) {
    "Overall (Global)"
  } else if (identical(by, "country")) {
    paste0("Grouped by country — top ", top_n_countries, " countries")
  } else {
    paste("Grouped by", by)
  }

  # Plot (bar chart only)
  p <- ggplot2::ggplot(show_data, ggplot2::aes(x = year, y = total_funding)) +
    ggplot2::geom_col(fill = "#0072BC") +
    unhcrthemes::theme_unhcr(grid = "Y", axis = "X", axis_title = "X", font_size = 20, legend = FALSE) +
    ggplot2::scale_y_continuous(labels = scales::label_number(scale_cut = scales::cut_short_scale())) +
    ggplot2::labs(
      title = paste("Funding Over Time from", donor_name),
      subtitle = subtitle_txt,
      x = "Year",
      y = "Total Funding (USD)",
      caption = "Source: Data published by UNHCR as part of the International Aid Transparency Initiative (IATI)"
    )

  # Facet if not global
  if (!is.null(facet_var)) {
    p <- p + ggplot2::facet_wrap(stats::as.formula(paste("~", facet_var)))
  }

  p
}

```

```{r example-show_donor_funding_over_time, message=FALSE, warning=FALSE, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center",  out.width = "90%"}
show_donor_funding_over_time(donor_name = "Private donors",
                                         year = c(2022, 2023, 20234, 2025),
                                         by = "global" )
show_donor_funding_over_time(donor_name = "Private donors",
                                         year = c(2022, 2023, 20234, 2025),
                                         by = "region" )
show_donor_funding_over_time(donor_name = "Private donors",
                                         year = c(2022, 2023, 20234, 2025),
                                         by = "earmarking_name" )
show_donor_funding_over_time(donor_name = "Private donors",
                                         year = c(2022, 2023, 20234, 2025),
                                         by = "country",
                                         top_n_countries = 10)

```
  
```{r tests-show_donor_funding_over_time}
test_that("show_donor_funding_over_time works", {
  expect_true(inherits(show_donor_funding_over_time, "function")) 
})
```

## show_donor_earmarking

```{r function-show_donor_earmarking}
#' Plot earmarking composition for a donor (stacked bar chart)
#'
#' @description
#' This function plots the earmarking composition of incoming commitments for a donor.
#' Depending on `by`, it shows a single global bar chart, bars by year, or stacked bars by
#' region/country/sector. All bar charts are ordered by total descending amount, except
#' for date grouping which is ordered chronologically.
#'
#' @param donor_name The name of the donor to plot.
#' @param year A numeric value or a vector of numeric values to filter on year.
#' @param by Grouping dimension: one of "global", "date", "region", "country", "sector".
#' @param programme_lab A character vector of programme labels to filter on.
#' @param iati_identifier_ops A character vector of operation identifiers to filter on.
#' @param ctr_name A character vector of country names to filter on.
#'
#' @import ggplot2
#' @import dplyr
#' @import scales
#' @import unhcrthemes
#'
#' @export
show_donor_earmarking <- function(donor_name,
                                  year = NULL,
                                  by = c("global", "date", "region", "country", "sector"),
                                  programme_lab = NULL,
                                  iati_identifier_ops = NULL,
                                  ctr_name = NULL) {

  by <- match.arg(by)

  # keep filters in separate objects to avoid name collision with column names
  year_filter <- year
  programme_filter <- programme_lab
  ops_filter <- iati_identifier_ops
  country_filter <- ctr_name

  # Basic data preparation
  df <- iati::dataTransaction |>
    dplyr::left_join(iati::dataActivity, by = "iati_identifier") |>
    dplyr::filter(
      transaction_provider_org == donor_name,
      transaction_type_name == "Incoming Commitment"
    )

  # Filtering (vector-friendly + safe evaluation)
  if (!is.null(year_filter)) {
    df <- df |> dplyr::filter(year %in% .env$year_filter)
  }
  if (!is.null(programme_filter)) {
    df <- df |> dplyr::filter(programme_lab %in% .env$programme_filter)
  } else if (!is.null(ops_filter)) {
    df <- df |> dplyr::filter(iati_identifier_ops %in% .env$ops_filter)
  } else if (!is.null(country_filter)) {
    df <- df |> dplyr::filter(ctr_name %in% .env$country_filter)
  }

  # Calculate total funding for the title
  total_funding_amount <- sum(df$transaction_value_USD, na.rm = TRUE)
  
  # Format total funding for display
  formatted_total <- scales::label_number(
    scale_cut = scales::cut_short_scale(),
    accuracy = 0.1
  )(total_funding_amount)
  
  # Build show_data with a single x column, depending on `by`
  show_data <- switch(
    by,

    "global" = {
      df |>
        dplyr::filter(!is.na(earmarking_name)) |>
        dplyr::group_by(earmarking_name) |>
        dplyr::summarise(
          total_funding = sum(transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::arrange(dplyr::desc(total_funding)) |>
        dplyr::mutate(x = "Global")
    },

    "date" = {
      # For date grouping, order by date chronologically
      df |>
        dplyr::filter(!is.na(earmarking_name), !is.na(year)) |>
        dplyr::group_by(year, earmarking_name) |>
        dplyr::summarise(
          total_funding = sum(transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::mutate(
          x = factor(year, levels = sort(unique(year)))
        )
    },

    "region" = {
      # Calculate region totals for ordering
      region_totals <- df |>
        dplyr::filter(!is.na(unhcr_region), !is.na(earmarking_name)) |>
        dplyr::group_by(unhcr_region) |>
        dplyr::summarise(
          region_total = sum(transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::arrange(dplyr::desc(region_total))
      
      df |>
        dplyr::filter(!is.na(unhcr_region), !is.na(earmarking_name)) |>
        dplyr::group_by(unhcr_region, earmarking_name) |>
        dplyr::summarise(
          total_funding = sum(transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::mutate(
          x = factor(unhcr_region, levels = rev(region_totals$unhcr_region))
        )
    },

    "country" = {
      # Calculate country totals for ordering
      country_totals <- df |>
        dplyr::filter(!is.na(ctr_name), !is.na(earmarking_name)) |>
        dplyr::group_by(ctr_name) |>
        dplyr::summarise(
          country_total = sum(transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::arrange(dplyr::desc(country_total))
      
      df |>
        dplyr::filter(!is.na(ctr_name), !is.na(earmarking_name)) |>
        dplyr::group_by(ctr_name, earmarking_name) |>
        dplyr::summarise(
          total_funding = sum(transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::mutate(
          x = factor(ctr_name, levels = rev(country_totals$ctr_name))
        )
    },

    "sector" = {
      # Calculate sector totals for ordering
      sector_totals <- df |>
        dplyr::left_join(iati::dataSector, by = "iati_identifier") |>
        dplyr::filter(!is.na(sector_desc), !is.na(earmarking_name)) |>
        dplyr::group_by(sector_desc) |>
        dplyr::summarise(
          sector_total = sum(transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::arrange(dplyr::desc(sector_total))
      
      df |>
        dplyr::left_join(iati::dataSector, by = "iati_identifier") |>
        dplyr::filter(!is.na(sector_desc), !is.na(earmarking_name)) |>
        dplyr::group_by(sector_desc, earmarking_name) |>
        dplyr::summarise(
          total_funding = sum(transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::mutate(
          x = factor(sector_desc, levels = rev(sector_totals$sector_desc))
        )
    }
  )

  # Create title with total funding amount and date information
  if (!is.null(year_filter) && length(year_filter) == 1) {
    title <- paste("Earmarking for", donor_name, "in", year_filter, "| Total:", formatted_total, "USD")
  } else if (!is.null(year_filter) && length(year_filter) > 1) {
    years_range <- paste(min(year_filter), "-", max(year_filter))
    title <- paste("Earmarking for", donor_name, years_range, "| Total:", formatted_total, "USD")
  } else {
    title <- paste("Earmarking for", donor_name, "| Total:", formatted_total, "USD")
  }

  # Define manual color scale for earmarking
  earmarking_colors <- c(
    "Tightly Earmarked" = "#C00000",
    "Earmarked" = "#FFC000",
    "Softly Earmarked" = "#0090BC",
    "Unearmarked" = "#36B3A1"
  )

  # Plot - special handling for global (regular bar chart with flipped coordinates)
  if (by == "global") {
    # For global, we want a regular bar chart (not stacked) with flip
    # Order bars so highest values are at top when flipped
    show_data <- show_data |>
      dplyr::mutate(
        earmarking_name = factor(earmarking_name, 
                                 levels = rev(unique(earmarking_name)))
      )
    
    p <- ggplot2::ggplot(
      show_data,
      ggplot2::aes(x = earmarking_name, y = total_funding, fill = earmarking_name)
    ) +
      ggplot2::geom_col() +
      unhcrthemes::theme_unhcr(grid = "X", axis = "Y", axis_title = "Y",
                               font_size = 20 ) +
      ggplot2::scale_y_continuous(
        labels = scales::label_number(scale_cut = scales::cut_short_scale())
      ) +
      ggplot2::scale_fill_manual(values = earmarking_colors) +
      ggplot2::coord_flip() +  # Always flip for global view
      ggplot2::labs(
        title = title,
        subtitle = "Global overview (ordered by total descending)",
        x = "Earmarking Type",
        y = "Total Funding (USD)",
        caption = "Source: Data published by UNHCR as part of the International Aid Transparency Initiative (IATI)"
      ) +
      ggplot2::theme(legend.position = "none")  # Hide legend for global view
    
  } else {
    # For other groupings, use stacked bar chart
    # Ensure earmarking_name is a factor with consistent levels
    show_data <- show_data |>
      dplyr::mutate(
        earmarking_name = factor(earmarking_name,
                                 levels = names(earmarking_colors))
      )
    
    # Create subtitle based on grouping type
    subtitle <- if (by == "date") {
      paste("Grouped by", by, "(ordered chronologically)")
    } else {
      paste("Grouped by", by, "(ordered by total descending)")
    }
    
    p <- ggplot2::ggplot(
      show_data,
      ggplot2::aes(x = x, y = total_funding, fill = earmarking_name)
    ) +
      ggplot2::geom_col(position = "stack") +
      unhcrthemes::theme_unhcr(grid = "X", axis = "Y", axis_title = "Y",
                               font_size = 20 ) +
      ggplot2::scale_y_continuous(
        labels = scales::label_number(scale_cut = scales::cut_short_scale())
      ) +
      ggplot2::scale_fill_manual(
        values = earmarking_colors,
        name = "Earmarking Type"
      ) +
      ggplot2::labs(
        title = title,
        subtitle = subtitle,
        x = NULL,
        y = "Total Funding (USD)",
        caption = "Source: Data published by UNHCR as part of the International Aid Transparency Initiative (IATI)"
      )
    
    # Flip for readability when there are many categories on x (not for date/global)
    if (by %in% c("region", "country", "sector")) {
      p <- p + ggplot2::coord_flip()
    }
  }

  p
}
```

```{r example-show_donor_earmarking, message=FALSE, warning=FALSE, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center",  out.width = "90%"}
show_donor_earmarking(donor_name = "Private donors",
                                         year = c(2022, 2023, 2024, 2025),
                                         by = "global") 
show_donor_earmarking(donor_name = "Private donors",
                                         year = c(2022, 2023, 2024, 2025),
                                         by = "date") 
show_donor_earmarking(donor_name = "Private donors",
                                         year = c(  2025),
                                         by = "region") 
```
  
```{r tests-show_donor_earmarking}
test_that("show_donor_earmarking works", {
  expect_true(inherits(show_donor_earmarking, "function")) 
})
```

## show_donor_earmarking_flexibility_over_time

```{r function-show_donor_earmarking_flexibility_over_time}
#' Plot donor earmarking flexibility over time
#'
#' @description This function creates a stacked bar chart showing the proportion
#' of each earmarking category for a specific donor over several years.
#'
#' @param donor_name The name of the donor to plot.
#' @param programme_lab A character vector corresponding to the name of the programme.
#' @param iati_identifier_ops A character vector corresponding to the name of the operation.
#' @param ctr_name A character vector corresponding to the name of the country.
#'
#' @import ggplot2
#' @import dplyr
#' @import scales
#' @import unhcrthemes
#'
#' @export
show_donor_earmarking_flexibility_over_time <- function(donor_name,
                                                        programme_lab = NULL,
                                                        iati_identifier_ops = NULL,
                                                        ctr_name = NULL) {

  # Basic data preparation
  df <- iati::dataTransaction |>
    dplyr::left_join(iati::dataActivity, by = "iati_identifier") |>
    dplyr::filter(transaction_provider_org == donor_name,
                  transaction_type_name == "Incoming Commitment")

  # Filtering
  if (!is.null(programme_lab)) {
    df <- df |> dplyr::filter(programmme_lab == {{programme_lab}})
  } else if (!is.null(iati_identifier_ops)) {
    df <- df |> dplyr::filter(iati_identifier_ops == {{iati_identifier_ops}})
  } else if (!is.null(ctr_name)) {
    df <- df |> dplyr::filter(ctr_name == {{ctr_name}})
  }

  # Summarization
  earmarking_over_time <- df |>
    dplyr::group_by(year, earmarking_name) |>
    dplyr::summarise(total_funding = sum(transaction_value_USD, na.rm = TRUE)) |>
    dplyr::filter(!is.na(earmarking_name))

  # Plotting
  p <- ggplot2::ggplot(earmarking_over_time, ggplot2::aes(x = year, y = total_funding, fill = earmarking_name)) +
    ggplot2::geom_bar(stat = "identity", position = "fill") +
    ggplot2::scale_y_continuous(labels = scales::percent_format()) +
    unhcrthemes::theme_unhcr(grid = "Y", axis = "X", axis_title = "X", font_size = 20) +
    ggplot2::labs(
      title = paste("Earmarking Flexibility Over Time for", donor_name, " in ",ctr_name ),
      subtitle = "Proportion of funding by earmarking category",
      x = "Year",
      y = "Proportion of Total Funding",
      fill = "Earmarking Type",
      caption = "Source: Data published by UNHCR as part of the International Aid Transparency Initiative (IATI)"
    )

  p
}
```

```{r example-show_donor_earmarking_flexibility_over_time, message=FALSE, warning=FALSE, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center",  out.width = "90%"}
# Earmarking Flexibility Over Time
show_donor_earmarking_flexibility_over_time(donor_name = "Private donors",
                                            ctr_name = "Syria")


```
  
```{r tests-show_donor_earmarking_flexibility_over_time}
test_that("show_donor_earmarking_flexibility_over_time works", {
  expect_true(inherits(show_donor_earmarking_flexibility_over_time, "function")) 
})
```

## show_donor_transaction_desc

```{r function-show_donor_transaction_desc}
#' Plot donor transaction description
#'
#' @description
#' Creates a visualization showing the breakdown of a donor's funding by transaction description.
#' If only `by` is NULL, it returns a bar chart of transaction descriptions.
#' If `by` is provided, it returns a heatmap cross-tabulation of transaction description vs the specified dimension.
#'
#' @param donor_name Character. The name of the donor to plot.
#' @param by Optional character. A second category to create a heatmap with transaction description.
#'   One of "unhcr_region", "year", "earmarking_name", or "ctr_name".
#' @param year Optional numeric/integer vector. Year(s) to filter on.
#' @param programme_lab Optional character vector. Filter for programme name.
#' @param iati_identifier_ops Optional character vector. Filter for operation ID.
#' @param ctr_name Optional character vector. Filter for country name.
#' @param top_n Integer. The number of top transaction descriptions to show.
#'
#' @return A ggplot object.
#'
#' @import ggplot2
#' @import dplyr
#' @import scales
#' @import forcats
#' @import stringr
#' @import unhcrthemes
#'
#' @export
show_donor_transaction_desc <- function(donor_name,
                                        by = NULL,
                                        year = NULL,
                                        programme_lab = NULL,
                                        iati_identifier_ops = NULL,
                                        ctr_name = NULL,
                                        top_n = 10) {

  # ---- 0) Validate inputs ----
  allowed_by <- c("unhcr_region", "year", "earmarking_name", "ctr_name")
  
  if (!is.null(by)) {
    if (!by %in% allowed_by) {
      stop("`by` must be one of: ", paste(allowed_by, collapse = ", "))
    }
  }
  
  if (!is.numeric(top_n) || length(top_n) != 1 || top_n < 1) {
    stop("`top_n` must be a single integer >= 1.")
  }

  # Avoid name collisions with columns (year arg vs year column, etc.)
  year_filter      <- year
  programme_filter <- programme_lab
  ops_filter       <- iati_identifier_ops
  country_filter   <- ctr_name

  # ---- 1) Load & filter data ----
  df <- iati::dataTransaction |>
    dplyr::left_join(iati::dataActivity, by = "iati_identifier") |>
    dplyr::filter(
      transaction_provider_org == donor_name,
      transaction_type_name == "Incoming Commitment"
    )

  if (!is.null(year_filter)) {
    df <- df |> dplyr::filter(year %in% .env$year_filter)
  }
  if (!is.null(programme_filter)) {
    df <- df |> dplyr::filter(programme_lab %in% .env$programme_filter)
  }
  if (!is.null(ops_filter)) {
    df <- df |> dplyr::filter(iati_identifier_ops %in% .env$ops_filter)
  }
  if (!is.null(country_filter)) {
    df <- df |> dplyr::filter(ctr_name %in% .env$country_filter)
  }



  # ---- 3) Determine grouping columns ----
  # Always include transaction_description, and add 'by' if provided
  col_vars <- c("transaction_description", by)
  col_vars <- col_vars[!is.null(col_vars)]

  # ---- 4) Aggregate (base) ----
  show_data <- df |>
    dplyr::filter(dplyr::if_all(dplyr::all_of(col_vars), ~ !is.na(.))) |>
    dplyr::group_by(dplyr::across(dplyr::all_of(col_vars))) |>
    dplyr::summarise(
      total_funding = sum(transaction_value_USD, na.rm = TRUE),
      .groups = "drop"
    )

  # ---- 5) Lumping helper (Top N + Other) ----
  lump_transaction_desc <- function(data, n) {
    data |>
      dplyr::mutate(
        transaction_description = forcats::fct_lump_n(
          forcats::fct_reorder(
            as.factor(transaction_description),
            total_funding,
            .fun = sum,
            .desc = TRUE
          ),
          n = n,
          w = total_funding,
          other_level = "Other"
        )
      )
  }
  
  # For "by" dimension handling
  process_by_dimension <- function(data, by_var) {
    if (is.null(by_var)) return(data)
    
    if (by_var == "earmarking_name") {
      # Preserve all 4 earmarking categories
      data <- data |>
        dplyr::mutate(
          earmarking_name = factor(earmarking_name,
            levels = c("Tightly Earmarked", "Earmarked", "Softly Earmarked", "Unearmarked")
          )
        )
    } else if (by_var == "year") {
      # Order years chronologically
      data <- data |>
        dplyr::mutate(
          year = factor(year, levels = sort(unique(year)))
        )
    } else if (by_var %in% c("unhcr_region", "ctr_name")) {
      # For region and country, show top categories based on data
      # These will be ordered by total in the heatmap
      data <- data
    }
    
    return(data)
  }

  # Apply lumping to transaction description (always)
  show_data <- lump_transaction_desc(show_data, top_n)
  
  # Process the 'by' dimension if provided
  show_data <- process_by_dimension(show_data, by)
  
  # Re-aggregate after lumping/processing
  show_data <- show_data |>
    dplyr::group_by(dplyr::across(dplyr::all_of(col_vars))) |>
    dplyr::summarise(total_funding = sum(total_funding, na.rm = TRUE), .groups = "drop")

  # ---- 6) Calculate total funding for title ----
  total_funding_amount <- sum(show_data$total_funding, na.rm = TRUE)
  formatted_total <- scales::label_number(
    scale_cut = scales::cut_short_scale(),
    accuracy = 0.1
  )(total_funding_amount)

  # ---- 7) Create title ----
  if (!is.null(year_filter) && length(year_filter) == 1) {
    title <- paste("Transaction Description for", donor_name, "in", year_filter, "| Total:", formatted_total, "USD")
  } else if (!is.null(year_filter) && length(year_filter) > 1) {
    years_range <- paste(min(year_filter), "-", max(year_filter))
    title <- paste("Transaction Description for", donor_name, years_range, "| Total:", formatted_total, "USD")
  } else {
    title <- paste("Transaction Description for", donor_name, "| Total:", formatted_total, "USD")
  }

  # ---- 8) Create subtitle ----
  subtitle_text <- if (is.null(by)) {
    if (!is.null(country_filter)) {
      paste0("In ", paste(country_filter, collapse = ", "))
    } else if (!is.null(programme_filter)) {
      paste0("For programme(s): ", paste(programme_filter, collapse = ", "))
    } else {
      paste0("Top ", top_n, " transaction descriptions")
    }
  } else {
    paste("Transaction description by", stringr::str_to_title(gsub("_", " ", by)))
  }

  # ---- 9) Plotting ----
  if (is.null(by)) {
    # BAR CHART - Transaction descriptions only
    
    # Prepare data for bar chart (summarize and order)
    bar_data <- show_data |>
      dplyr::group_by(transaction_description) |>
      dplyr::summarise(total_funding = sum(total_funding, na.rm = TRUE), .groups = "drop") |>
      dplyr::mutate(
        transaction_description = forcats::fct_reorder(transaction_description, total_funding, .desc = FALSE)
      )
    
    p <- ggplot2::ggplot(
      bar_data,
      ggplot2::aes(x = transaction_description, y = total_funding)
    ) +
      ggplot2::geom_col(fill = "#0072BC") +
      ggplot2::coord_flip() +
      ggplot2::scale_y_continuous(
        labels = scales::label_number(scale_cut = scales::cut_short_scale())
      ) +
      unhcrthemes::theme_unhcr(grid = "X", axis = "y", axis_title = "X", font_size = 20) +
      ggplot2::labs(
        title = title,
        subtitle = subtitle_text,
        x = "Transaction Description",
        y = "Total Funding (USD)",
        caption = "Source: Data published by UNHCR as part of the International Aid Transparency Initiative (IATI)"
      )

  } else {
    # HEATMAP - Transaction description by another dimension
    
    # Determine axis labels
    x_label <- if (by == "ctr_name") "Country" else stringr::str_to_title(gsub("_", " ", by))
    y_label <- "Transaction Description"
    
    # Order transaction descriptions by total funding (highest at top)
    heatmap_data <- show_data |>
      dplyr::group_by(transaction_description) |>
      dplyr::mutate(desc_total = sum(total_funding)) |>
      dplyr::ungroup() |>
      dplyr::mutate(
        transaction_description = forcats::fct_reorder(transaction_description, desc_total, .desc = TRUE)
      )
    
    # For year dimension, ensure proper ordering on x-axis
    if (by == "year") {
      heatmap_data <- heatmap_data |>
        dplyr::mutate(
          !!rlang::sym(by) := factor(!!rlang::sym(by), levels = sort(unique(!!rlang::sym(by))))
        )
    }
    
    p <- ggplot2::ggplot(
      heatmap_data,
      ggplot2::aes(
        x = !!rlang::sym(by),
        y = transaction_description,
        fill = total_funding
      )
    ) +
      ggplot2::geom_tile(color = "white", linewidth = 0.5) +
      ggplot2::scale_fill_gradient(
        low = "#DCEEF9",
        high = "#0072BC",
        labels = scales::label_number(scale_cut = scales::cut_short_scale())
      ) +
      unhcrthemes::theme_unhcr(grid = FALSE, axis = "xy", font_size = 20) +
      ggplot2::theme(
        axis.text.x = ggplot2::element_text(angle = 45, vjust = 1, hjust = 1)
      ) +
      ggplot2::labs(
        title = title,
        subtitle = subtitle_text,
        x = x_label,
        y = y_label,
        fill = "Funding (USD)",
        caption = "Source: Data published by UNHCR as part of the International Aid Transparency Initiative (IATI)"
      )
  }

  p
}
```

```{r example-show_donor_transaction_desc, message=FALSE, warning=FALSE, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center",  out.width = "90%"}

# Show top 10 transaction descriptions for a donor
show_donor_transaction_desc(
  donor_name = "Private donors", 
  year = 2024,
  top_n = 10
)

# Show top 10 transaction descriptions for a donor
show_donor_transaction_desc(
  donor_name = "Private donors", 
  year = 2022:2025,
  top_n = 10
)

# Show earmarking breakdown with proper color coding
show_donor_transaction_desc(
  donor_name = "Private donors",
  by = "earmarking_name",
  year = 2024,
  top_n = 4  # Shows all 4 earmarking types
)

# Show funding by region
show_donor_transaction_desc(
  donor_name = "Private donors",
  by = "unhcr_region",
  year = 2025,
  top_n = 8
)


```
  
```{r tests-show_donor_transaction_desc}
test_that("show_donor_transaction_desc works", {
  expect_true(inherits(show_donor_transaction_desc, "function")) 
})
```

## compare_donor_profiles

```{r function-compare_donor_profiles}
#' Compare donor profiles
#'
#' @description
#' Creates an overlaid bar chart to compare funding profiles of donors based on
#' a selected dimension (earmarking, region, or country). When only one donor 
#' is provided, a comparator is automatically added based on other donors.
#'
#' @param donor_names Character vector of donor names to compare (length 1 or more).
#' @param by One of "earmarking", "region", or "country". The dimension to compare.
#' @param avg_method If only one donor is supplied, how to compute the "others" comparator:
#'   - "mean_of_donors": Each donor counts equally, regardless of their total funding
#'   - "pooled": Donors are weighted by their share of total funding (larger donors have more influence)
#' @param display_mode Comparison mode:
#'   - "absolute": Compare absolute USD amounts (sum vs sum)
#'   - "relative": Compare percentage shares of total funding (profile vs average profile)
#' @param year Optional numeric/integer vector. Year(s) to filter on.
#' @param unhcr_region Optional character vector. Filter for UNHCR region(s).
#' @param programme_lab Optional character vector. Filter for programme name.
#' @param iati_identifier_ops Optional character vector. Filter for operation ID.
#' @param ctr_name Optional character vector. Filter for country name.
#' @param top_n Integer. The number of top categories to show when `by = "country"`.
#'
#' @return A ggplot object showing overlaid bars for comparison.
#'
#' @details
#' When `display_mode = "relative"` and a comparator is added:
#' - Selected donor: Percentage share of its own total funding
#' - Comparator: Average percentage share across other donors (using `avg_method`)
#' 
#' When `display_mode = "absolute"` and a comparator is added:
#' - Selected donor: Absolute USD amounts
#' - Comparator: Either:
#'   - With `avg_method = "mean_of_donors"`: Average donor size × average share
#'   - With `avg_method = "pooled"`: Summed totals across all other donors
#'
#' The chart uses visual cues to distinguish series:
#' - Wider transparent bars: Comparator
#' - Narrower solid bars: Selected donor(s)
#' - Colors represent categories within the dimension
#'
#' @import ggplot2
#' @import dplyr
#' @import scales
#' @import unhcrthemes
#'
#' @export
compare_donor_profiles <- function(donor_names,
                                   by = c("earmarking", "region", "country"),
                                   avg_method = c("mean_of_donors", "pooled"),
                                   display_mode = c("absolute", "relative"),
                                   year = NULL,
                                   unhcr_region = NULL,
                                   programme_lab = NULL,
                                   iati_identifier_ops = NULL,
                                   ctr_name = NULL,
                                   top_n = NULL) {

  by <- match.arg(by)
  avg_method <- match.arg(avg_method)
  display_mode <- match.arg(display_mode)

  # Avoid collisions with column names
  year_filter      <- year
  region_filter    <- unhcr_region
  programme_filter <- programme_lab
  ops_filter       <- iati_identifier_ops
  country_filter   <- ctr_name

  donor_names <- unique(donor_names)
  add_comparator <- length(donor_names) == 1

  # ---- 1) Load base data (ALL donors), then apply filters ----
  df_base <- iati::dataTransaction |>
    dplyr::left_join(iati::dataActivity, by = "iati_identifier") |>
    dplyr::filter(transaction_type_name == "Incoming Commitment")

  if (!is.null(year_filter)) {
    df_base <- df_base |> dplyr::filter(year %in% .env$year_filter)
  }
  if (!is.null(region_filter)) {
    df_base <- df_base |> dplyr::filter(unhcr_region %in% .env$region_filter)
  }
  if (!is.null(programme_filter)) {
    df_base <- df_base |> dplyr::filter(programme_lab %in% .env$programme_filter)
  }
  if (!is.null(ops_filter)) {
    df_base <- df_base |> dplyr::filter(iati_identifier_ops %in% .env$ops_filter)
  }
  if (!is.null(country_filter)) {
    df_base <- df_base |> dplyr::filter(ctr_name %in% .env$country_filter)
  }



  # ---- 2) Helper: build (donor, dimension, total_funding) ----
  build_profile <- function(df_in, by) {
    if (by == "earmarking") {
      df_in |>
        dplyr::filter(!is.na(earmarking_name)) |>
        dplyr::group_by(transaction_provider_org, earmarking_name) |>
        dplyr::summarise(
          total_funding = sum(transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::rename(dimension = earmarking_name)
    } else if (by == "region") {
      df_in |>
        dplyr::group_by(transaction_provider_org, unhcr_region) |>
        dplyr::summarise(
          total_funding = sum(transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::rename(dimension = unhcr_region)
    } else { # by == "country"
      df_in |>
        dplyr::filter(!is.na(ctr_name)) |>
        dplyr::group_by(transaction_provider_org, ctr_name) |>
        dplyr::summarise(
          total_funding = sum(transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::rename(dimension = ctr_name)
    }
  }

  # ---- 3) Selected donors ----
  selected_df <- df_base |>
    dplyr::filter(transaction_provider_org %in% .env$donor_names)

  show_selected <- build_profile(selected_df, by)

  if (nrow(show_selected) == 0) {
    stop("No data found for the selected donor(s) under the specified filters.")
  }

  # ---- 4) Auto comparator if only one donor provided ----
  comparator_label <- NULL

  if (add_comparator) {
    focal <- donor_names[[1]]

    others_df <- df_base |>
      dplyr::filter(transaction_provider_org != .env$focal)

    show_others <- build_profile(others_df, by)

    if (nrow(show_others) == 0) {
      warning("No data found for 'other donors' under the specified filters. Showing only selected donor.")
      show_data <- show_selected
      add_comparator <- FALSE
      
    } else {

      if (avg_method == "mean_of_donors") {
        comparator_label <- "Average of other donors (equal weight)"
        
        # For relative display: average of donor-level percentage shares
        if (display_mode == "relative") {
          # Calculate percentage shares for each other donor
          others_totals <- show_others |>
            dplyr::group_by(transaction_provider_org) |>
            dplyr::summarise(donor_total = sum(total_funding, na.rm = TRUE), .groups = "drop")
          
        # First, get complete set of dimensions across all other donors
        all_dimensions <- unique(show_others$dimension)
        
        others_shares <- show_others |>
          dplyr::left_join(others_totals, by = "transaction_provider_org") |>
          # Calculate shares, treating missing as 0
          dplyr::mutate(
            share = dplyr::if_else(donor_total > 0, 
                                  total_funding / donor_total, 
                                  0)
          ) |>
          # Ensure we have all dimensions for each donor
          tidyr::complete(
            transaction_provider_org,
            dimension = all_dimensions,
            fill = list(share = 0, total_funding = 0, donor_total = 0)
          ) |>
          # Now average the shares (including 0s for missing dimensions)
          dplyr::group_by(dimension) |>
          dplyr::summarise(avg_share = mean(share, na.rm = FALSE), .groups = "drop")
          
          show_cmp <- others_shares |>
            dplyr::mutate(
              transaction_provider_org = comparator_label,
              total_funding = NA_real_,  # Not used for relative display
              share = avg_share
            ) |>
            dplyr::select(transaction_provider_org, dimension, total_funding, share)
          
      } else { # display_mode == "absolute"
        # Calculate actual average dollar amounts per donor
        # First, ensure we have all dimensions for each donor (treat missing as 0)
        all_dimensions <- unique(show_others$dimension)
        
        # Create complete data frame with all donor-dimension combinations
        complete_others <- show_others |>
          tidyr::complete(
            transaction_provider_org,
            dimension = all_dimensions,
            fill = list(total_funding = 0)
          )
        
        # Calculate average dollar amount per donor for each dimension
        avg_funding_by_dim <- complete_others |>
          dplyr::group_by(dimension) |>
          dplyr::summarise(
            avg_funding = mean(total_funding, na.rm = TRUE),
            .groups = "drop"
          )
        
        show_cmp <- avg_funding_by_dim |>
          dplyr::mutate(
            transaction_provider_org = comparator_label,
            total_funding = avg_funding,
            share = NA_real_  # Not used in absolute mode
          ) |>
          dplyr::select(transaction_provider_org, dimension, total_funding, share)
      }

      } else if (avg_method == "pooled") {
        comparator_label <- "Other donors (pooled)"
        
        # For both relative and absolute: use pooled totals
        pooled_totals <- show_others |>
          dplyr::group_by(dimension) |>
          dplyr::summarise(
            total_funding = sum(total_funding, na.rm = TRUE),
            .groups = "drop"
          )
        
        if (display_mode == "relative") {
          # Calculate percentage share of pooled total
          grand_total <- sum(pooled_totals$total_funding, na.rm = TRUE)
          show_cmp <- pooled_totals |>
            dplyr::mutate(
              transaction_provider_org = comparator_label,
              share = total_funding / grand_total
            ) |>
            dplyr::select(transaction_provider_org, dimension, total_funding, share)
        } else { # display_mode == "absolute"
          show_cmp <- pooled_totals |>
            dplyr::mutate(
              transaction_provider_org = comparator_label,
              share = NA_real_
            ) |>
            dplyr::select(transaction_provider_org, dimension, total_funding, share)
        }
      }

      # Calculate shares for selected donor
      selected_total <- sum(show_selected$total_funding, na.rm = TRUE)
      show_selected <- show_selected |>
        dplyr::mutate(
          share = total_funding / selected_total
        )
      
      show_data <- dplyr::bind_rows(show_selected, show_cmp)
    }

  } else {
    # Multiple donors - calculate shares if needed
    if (display_mode == "relative") {
      donor_totals <- show_selected |>
        dplyr::group_by(transaction_provider_org) |>
        dplyr::summarise(donor_total = sum(total_funding, na.rm = TRUE), .groups = "drop")
      
      show_data <- show_selected |>
        dplyr::left_join(donor_totals, by = "transaction_provider_org") |>
        dplyr::mutate(
          share = total_funding / donor_total
        ) |>
        dplyr::select(-donor_total)
    } else {
      show_data <- show_selected |>
        dplyr::mutate(share = NA_real_)
    }
  }

  # ---- 5) Apply top_n filter for country dimension ----
  if (by == "country" && !is.null(top_n) && is.numeric(top_n)) {
    # Keep top_n countries based on total funding across all shown donors
    top_countries <- show_data |>
      dplyr::group_by(dimension) |>
      dplyr::summarise(total = sum(total_funding, na.rm = TRUE), .groups = "drop") |>
      dplyr::arrange(dplyr::desc(total)) |>
      dplyr::slice(1:top_n) |>
      dplyr::pull(dimension)
    
    show_data <- show_data |>
      dplyr::filter(dimension %in% top_countries)
  }

  # ---- 6) Prepare data for overlaid bar chart ----
  # Create factor levels for dimension ordered by total funding
  dimension_levels <- show_data |>
    dplyr::group_by(dimension) |>
    dplyr::summarise(total = sum(total_funding, na.rm = TRUE), .groups = "drop") |>
    dplyr::arrange(dplyr::desc(total)) |>
    dplyr::pull(dimension)
  
  # Add type column for plotting
  
  if (is.null(comparator_label)) comparator_label <- NA_character_
  show_data <- show_data |>
    dplyr::mutate(
      dimension = factor(dimension, levels = dimension_levels),
      type = dplyr::case_when(
        transaction_provider_org %in% donor_names & add_comparator ~ "Selected Donor",
        transaction_provider_org %in% donor_names & !add_comparator ~ "Selected Donors",
        transaction_provider_org == comparator_label ~ "Comparator",
        TRUE ~ "Other"
      ),
      # Select value based on display mode
      value = if (display_mode == "absolute") total_funding else share
    )

  # ---- 7) Define colors and aesthetics ----
  # Use earmarking colors if by = "earmarking"
  if (by == "earmarking") {
    earmarking_colors <- c(
      "Tightly Earmarked" = "#C00000",
      "Earmarked" = "#FFC000",
      "Softly Earmarked" = "#0090BC",
      "Unearmarked" = "#36B3A1"
    )
    
    # Ensure colors match the dimension levels
    fill_colors <- earmarking_colors[dimension_levels[dimension_levels %in% names(earmarking_colors)]]
  } else {
    # For region and country, use a color palette
    fill_colors <- unhcrthemes::unhcr_pal(n = length(dimension_levels), "pal_unhcr")
    names(fill_colors) <- dimension_levels
  }

  # ---- 8) Create title ----
  # Build year string for title
  year_str <- if (!is.null(year_filter)) {
    if (length(year_filter) == 1) {
      paste("in", year_filter)
    } else {
      paste(range(year_filter), collapse = "-")
    }
  } else {
    "all years"
  }
  
  # Build title based on number of donors and display mode
  if (add_comparator) {
    if (display_mode == "relative") {
      title <- paste(donor_names[1], "vs average | ", year_str)
    } else {
      title <- paste(donor_names[1], "vs", tolower(gsub("\\(.*\\)", "", comparator_label)), ":", stringr::str_to_title(by), "profile", year_str)
    }
  } else if (length(donor_names) == 1) {
    title <- paste(donor_names[1], ":", stringr::str_to_title(by), "profile", year_str)
  } else {
    title <- paste("Comparison of", paste(donor_names, collapse = " & "), ":", stringr::str_to_title(by), "profile", year_str)
  }
  
  # Capitalize first letter of each word
  title <- stringr::str_to_title(title)

  # ---- 9) Build interpretation hints for caption ----
  caption_parts <- c(
    "Source: Data published by UNHCR as part of the International Aid Transparency Initiative (IATI)"
  )
  
  # Add interpretation hints
  if (add_comparator) {
    caption_parts <- c(caption_parts, 
                       "Wider transparent bars: Comparator | Narrower solid bars: Selected donor")
    
    # Add method hint
    method_desc <- if (avg_method == "mean_of_donors") {
      "Comparator: average of donor-level shares (each donor counts equally)"
    } else {
      "Comparator: pooled totals (donors weighted by funding share)"
    }
    caption_parts <- c(caption_parts, method_desc)
  }
  
  if (by == "earmarking") {
    caption_parts <- c(caption_parts, 
                       "Colors: Tightly Earmarked (red), Earmarked (orange), Softly Earmarked (blue), Unearmarked (green)")
  }
  
  if (display_mode == "relative") {
    caption_parts <- c(caption_parts, "Values: percentage share of total funding")
  } else {
    caption_parts <- c(caption_parts, "Values: absolute USD amounts")
  }
  
  # Add filter information if any filters applied
  filter_parts <- c()
  if (!is.null(region_filter) && length(region_filter) <= 3) {
    filter_parts <- c(filter_parts, paste("Region:", paste(region_filter, collapse = ", ")))
  }
  if (!is.null(country_filter) && length(country_filter) <= 3) {
    filter_parts <- c(filter_parts, paste("Country:", paste(country_filter, collapse = ", ")))
  }
  if (!is.null(programme_filter) && length(programme_filter) <= 2) {
    filter_parts <- c(filter_parts, paste("Programme:", paste(programme_filter, collapse = ", ")))
  }
  
  if (length(filter_parts) > 0) {
    caption_parts <- c(caption_parts, paste("Filters:", paste(filter_parts, collapse = "; ")))
  }
  
  caption <- paste(caption_parts, collapse = " | ")

  # ---- 10) Plot: Fully overlaid bar chart ----
  # Separate data for plotting
  plot_data <- show_data
  
  # Set bar widths and transparency
  bar_widths <- c("Selected Donor" = 0.6, "Selected Donors" = 0.6, "Comparator" = 0.8)
  bar_alphas <- c("Selected Donor" = 0.9, "Selected Donors" = 0.9, "Comparator" = 0.4)
  
  # Get unique types in correct order (Comparator first for layering)
  types_in_data <- unique(plot_data$type)
  # Ensure Comparator is drawn first (behind) if present
  if ("Comparator" %in% types_in_data) {
    plot_order <- c("Comparator", setdiff(types_in_data, "Comparator"))
  } else {
    plot_order <- types_in_data
  }
  
  # Create base plot
  p <- ggplot2::ggplot()
  
  # Add bars in correct order (comparator first, then selected donor)
  for (bar_type in plot_order) {
    type_data <- plot_data |> dplyr::filter(type == bar_type)
    
    if (nrow(type_data) > 0) {
      p <- p + ggplot2::geom_col(
        data = type_data,
        ggplot2::aes(x = dimension, y = value, fill = dimension),
        width = bar_widths[bar_type],
        alpha = bar_alphas[bar_type],
        position = "identity",  # Fully overlaid
        show.legend = FALSE      # Suppress individual bar legends
      )
    }
  }
  
  # Build the complete plot with all elements before applying any theme
  p <- p +
    ggplot2::coord_flip() +
    ggplot2::scale_fill_manual(values = fill_colors) +
    ggplot2::labs(
      title = title,
      x = NULL,
      y = if (display_mode == "absolute") "Total Funding (USD)" else "Share of Total Funding (%)",
      caption = caption
    )
  
  # Add appropriate y-axis scale
  if (display_mode == "absolute") {
    p <- p + ggplot2::scale_y_continuous(
      labels = scales::label_number(scale_cut = scales::cut_short_scale()),
      expand = ggplot2::expansion(mult = c(0, 0.1))
    )
  } else {
    p <- p + ggplot2::scale_y_continuous(
      labels = scales::label_percent(accuracy = 1),
      expand = ggplot2::expansion(mult = c(0, 0.05))
    )
  }
  
  p <- p + 
    unhcrthemes::theme_unhcr(grid = "X", axis = "Y", axis_title = "Y", 
                             font_size = 20, 
                             legend = FALSE) 

  
  return(p)
}
```

```{r example-compare_donor_profiles, message=FALSE, warning=FALSE, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center",  out.width = "90%"}
# Compare Donor Profiles

## using mean
compare_donor_profiles(
  donor_names = "Private donors",
  by = "earmarking",
  year = 2025,
  avg_method = "mean_of_donors",
  display_mode = "absolute"
)
compare_donor_profiles(
  donor_names = "Private donors",
  by = "earmarking",
  year = 2025,
  avg_method = "mean_of_donors",
  display_mode = "relative"
)

## using pooled
compare_donor_profiles(
  donor_names = "Private donors",
  by = "earmarking",
  year = 2025,
  avg_method = "pooled",
  display_mode = "absolute"
)


compare_donor_profiles(
  donor_names = "Private donors",
  by = "earmarking",
  year = 2025,
  avg_method = "pooled",
  display_mode = "relative"
)


compare_donor_profiles(
  donor_names = "Private donors",
  by = "region",
  year = 2025,
  avg_method = "pooled",
  display_mode = "relative"
)

compare_donor_profiles(
  donor_names = c("Private donors", 
 "Switzerland - Swiss Agency for Development and Cooperation (SDC)"), 
   by = "earmarking", 
 year = 2025, 
 ctr_name = "Brazil")
```
  
```{r tests-compare_donor_profiles}
test_that("show_compare_donor_profiles works", {
  expect_true(inherits(compare_donor_profiles, "function")) 
})
```

## show_donor_geographic_priority_shift

```{r function-show_donor_geographic_priority_shift}

#' Plot donor geographic priority shift over time (alluvial, CVD-safe colors + correct labels)
#'
#' @param donor_name The donor to highlight.
#' @param top_n_countries Number of top recipient countries to display.
#' @param start_year Optional start year.
#' @param end_year Optional end year.
#' @param verbose Print diagnostic messages.
#' 
#' @import ggplot2
#' @import dplyr
#' @importFrom ggalluvial geom_alluvium
#'
#' @return A fully labeled ggalluvial plot.
#' @export
show_donor_geographic_priority_shift <- function(
  donor_name,
  top_n_countries = 5,
  start_year = NULL,
  end_year = NULL,
  verbose = TRUE
) {

  # ---- Required packages ----
  if (!requireNamespace("ggalluvial", quietly = TRUE)) {
    stop("Package `ggalluvial` is required. Install with install.packages('ggalluvial').")
  }
  has_ggrepel <- requireNamespace("ggrepel", quietly = TRUE)

  # ---- Load data ----
  data_activity    <- iati::dataActivity
  data_transaction <- iati::dataTransaction

  # ---- Prepare data ----
  df_plot <- data_transaction |>
    dplyr::inner_join(
      data_activity |> dplyr::select(iati_identifier, ctr_name),
      by = "iati_identifier"
    ) |>
    dplyr::mutate(
      year = lubridate::year(lubridate::ymd(transaction_date)),
      transaction_value = as.numeric(transaction_value)
    ) |>
    dplyr::filter(
      !is.na(year),
      !is.na(transaction_value_USD),
      !is.na(ctr_name)
    ) |>
    dplyr::group_by(transaction_provider_org, year, ctr_name) |>
    dplyr::summarise(
      total_funding = sum(transaction_value_USD, na.rm = TRUE),
      .groups = "drop"
    )

  # ---- Year filters ----
  if (!is.null(start_year)) df_plot <- dplyr::filter(df_plot, year >= start_year)
  if (!is.null(end_year))   df_plot <- dplyr::filter(df_plot, year <= end_year)

  # ---- Donor subset ----
  df_donor <- df_plot |>
    dplyr::filter(transaction_provider_org == donor_name) |>
    dplyr::group_by(year) |>
    dplyr::mutate(total_year_funding = sum(total_funding)) |>
    dplyr::ungroup() |>
    dplyr::filter(total_year_funding > 0) |>
    dplyr::mutate(
      funding_pct = total_funding / total_year_funding,
      recipient_country = forcats::fct_reorder(
        ctr_name, total_funding, .fun = sum, .desc = TRUE
      )
    )

  # ---- Identify Top-N Countries ----
  top_countries <- df_donor |>
    dplyr::group_by(recipient_country) |>
    dplyr::summarise(tot = sum(total_funding)) |>
    dplyr::arrange(desc(tot)) |>
    utils::head(top_n_countries) |>
    dplyr::pull(recipient_country) |>
    as.character()

  # ---- Collapse others ----
  df_show <- df_donor |>
    dplyr::mutate(
      country_group = ifelse(
        recipient_country %in% top_countries,
        as.character(recipient_country),
        "Other Countries"
      )
    ) |>
    dplyr::group_by(year, country_group) |>
    dplyr::summarise(funding_pct = sum(funding_pct), .groups = "drop") |>
    dplyr::ungroup()

  # ---- Factor ordering ----
  level_order <- c(top_countries, "Other Countries")

  df_show <- df_show |>
    dplyr::mutate(
      country_group = factor(country_group, levels = level_order),
      year_fct = factor(year, levels = sort(unique(year)))
    )

  # ---- CVD-safe palette ----
  get_cvd_palette <- function(n) {
    okabe_ito <- c(
      "#0072B2", "#E69F00", "#009E73", "#D55E00",
      "#CC79A7", "#56B4E9", "#F0E442", "#000000"
    )
    if (n <= length(okabe_ito)) okabe_ito[seq_len(n)]
    else if (requireNamespace("viridisLite", quietly = TRUE))
      viridisLite::viridis(n)
    else rep(okabe_ito, length.out = n)
  }

  top_cols <- get_cvd_palette(length(top_countries))
  grey_other <- "#B3B3B3"

  fill_values <- stats::setNames(
    c(top_cols, grey_other),
    c(top_countries, "Other Countries")
  )

  # ---- Build alluvial plot (NO labels yet) ----
  p <- ggplot2::ggplot(
    df_show,
    ggplot2::aes(
      x = year_fct,
      y = funding_pct,
      alluvium = country_group,
      stratum = country_group,
      fill = country_group
    )
  ) +
    ggalluvial::geom_alluvium(
      width = 0.25,
      knot.pos = 0.4,
      aes.bind = "flows",
      decreasing = FALSE,
      alpha = 0.9
    ) +
    ggplot2::scale_fill_manual(values = fill_values) +
    ggplot2::scale_y_continuous(labels = scales::percent) +
    ggplot2::scale_x_discrete(expand = ggplot2::expansion(add = c(0.05, 0.05))) +
    ggplot2::labs(
      title = paste0("Disbursements Shift for ", donor_name),
      #subtitle = " ",
      x = "",
      y = ""
    ) +
    unhcrthemes::theme_unhcr( legend = TRUE,
                              legend_title = FALSE,
                             font_size = 20) +

    ggplot2::coord_cartesian(clip = "off")

  # ---- Extract TRUE ymax/ymin from plotted polygons ----
  pb <- ggplot_build(p)
  alluvium_df <- pb$data[[1]]

  last_year <- max(df_show$year)
  last_year_fct <- as.character(last_year)

  last_x_id <- which(levels(df_show$year_fct) == last_year_fct)

  ribbon_bounds <- alluvium_df |>
    dplyr::filter(x == last_x_id) |>
    dplyr::group_by(fill) |>
    dplyr::summarise(
      ymin = min(y),
      ymax = max(y),
      y_mid = (ymin + ymax) / 2,
      .groups = "drop"
    )

  labels_df <- ribbon_bounds |>
    dplyr::mutate(
      country_group = names(fill_values)[match(fill, fill_values)],
      label = ifelse(country_group == "Other Countries", "Other", country_group),
      year_fct = last_year_fct
    )

  # # ---- Add Direct Labels ----
  # if (has_ggrepel) {
  #   p <- p +
  #     ggrepel::geom_label_repel(
  #       data = labels_df,
  #       ggplot2::aes(x = year_fct, y = y_mid, label = label),
  #       inherit.aes = FALSE,
  #       nudge_x = 0.4,
  #       hjust = 0,
  #       direction = "y",
  #       segment.color = "grey60",
  #       size = 7,
  #       max.overlaps = Inf
  #     )
  # } else {
  #   p <- p +
  #     ggplot2::geom_text(
  #       data = labels_df,
  #       ggplot2::aes(x = year_fct, y = y_mid, label = label),
  #       inherit.aes = FALSE,
  #       hjust = 0,
  #       nudge_x = 0.25,
  #       size = 6.5
  #     )
  # }

  return(p)
}

```

```{r example-show_donor_geographic_priority_shift, message=FALSE, warning=FALSE, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center",  out.width = "90%"}
# Example usage: 
show_donor_geographic_priority_shift(
   donor_name = "Private donors", 
   top_n_countries = 7,
   start_year = 2022,
   end_year = 2025
 )
```

```{r tests-show_donor_geographic_priority_shift}
test_that("show_donor_geographic_priority_shift works", {
  # Test with a specific donor
  p_geo1 <- show_donor_geographic_priority_shift( 
    donor_name = "Private donors", 
    top_n_countries = 4,
   start_year = 2022,
   end_year = 2025
  )
  expect_true(ggplot2::is_ggplot(p_geo1)) 

})
```

## show_donor_activity_diversification

```{r function-show_donor_activity_diversification}

#' Plot donor activity diversification over time
#' (percentage coverage vs. benchmark lines: Top 5%, Top 10%, Top 50% donors)
#' with donor points, per-year labels (number of operations), and LOESS smoothing
#'
#' @description
#' Shows the **% of UNHCR operations (countries)** covered by a selected donor each year.
#' Adds three benchmark lines: the **average** coverage (per year) for donors ranked
#' by annual funding in the **Top 5%**, **Top 10%**, and **Top 50%**.
#' The donor’s path uses **geom_smooth(method = "loess", se = FALSE)** instead of a straight line,
#' with **points** and **`ggrepel` labels** (absolute # of countries) for the donor only.
#'
#' @param donor_name Character. Donor to highlight (`transaction_provider_org`).
#' @param start_year Optional integer. Inclusive lower bound on year.
#' @param end_year Optional integer. Inclusive upper bound on year.
#' @param loess_span Numeric (0–1+). LOESS span for donor smoothing (default 0.6).
#' @param verbose Logical. Print diagnostics (default TRUE).
#'
#' @return A ggplot object.
#'
#' @import dplyr ggplot2 scales forcats unhcrthemes
#' @importFrom tidyr pivot_longer
#' @export
show_donor_activity_diversification <- function(
  donor_name,
  start_year = NULL,
  end_year   = NULL,
  loess_span = 0.6,
  verbose    = TRUE
) {
  # ---- Data ----
  data_activity    <- iati::dataActivity
  data_transaction <- iati::dataTransaction

  # ---- Prepare joined dataset ----
  df <- data_transaction |>
    dplyr::filter(transaction_type_name == "Incoming Commitment") |>
    dplyr::left_join(
      data_activity |> dplyr::select(iati_identifier, ctr_name),
      by = "iati_identifier"
    ) |>
    dplyr::mutate(year = lubridate::year(lubridate::ymd(transaction_date))) |>
    dplyr::filter(!is.na(year), !is.na(ctr_name))

  # ---- Year filter ----
  if (!is.null(start_year)) df <- df |> dplyr::filter(year >= start_year)
  if (!is.null(end_year))   df <- df |> dplyr::filter(year <= end_year)
  if (nrow(df) == 0) stop("No data after filtering (check start_year/end_year).")

  # ---- Denominator: total # countries per year ----
  total_countries_by_year <- df |>
    dplyr::group_by(year) |>
    dplyr::summarise(total_countries = dplyr::n_distinct(ctr_name), .groups = "drop")

  # ---- Donor-year: countries covered & coverage % ----
  donor_countries_by_year <- df |>
    dplyr::group_by(transaction_provider_org, year) |>
    dplyr::summarise(
      num_countries      = dplyr::n_distinct(ctr_name),
      total_funding_year = sum(transaction_value_USD, na.rm = TRUE),
      .groups = "drop"
    ) |>
    dplyr::left_join(total_countries_by_year, by = "year") |>
    dplyr::mutate(coverage_pct = num_countries / total_countries)

  # ---- Focal donor series ----
  donor_exists <- donor_name %in% donor_countries_by_year$transaction_provider_org
  donor_series <- donor_countries_by_year |>
    dplyr::filter(transaction_provider_org == .env$donor_name)

  if (!donor_exists) {
    warning("Donor '", donor_name, "' not found in filtered data. Plot will show benchmarks only.")
  }

  # Labels for donor: per-year #countries (operations)
  donor_labels_df <- NULL
  if (donor_exists && nrow(donor_series) > 0) {
    donor_labels_df <- donor_series |>
      dplyr::mutate(label_txt = as.character(num_countries))
  }

  # ---- Benchmarks: Top 5%, Top 10%, Top 50% (per year) ----
  ranks <- donor_countries_by_year |>
    dplyr::group_by(year) |>
    dplyr::arrange(dplyr::desc(total_funding_year), .by_group = TRUE) |>
    dplyr::mutate(
      n_donors = dplyr::n(),
      rank     = dplyr::row_number(),
      # ensure at least 1 donor per threshold:
      k5  = pmax(1L, ceiling(0.05 * n_donors)),
      k10 = pmax(1L, ceiling(0.10 * n_donors)),
      k50 = pmax(1L, ceiling(0.50 * n_donors)),
      in_top5  = rank <= k5,
      in_top10 = rank <= k10,
      in_top50 = rank <= k50
    ) |>
    dplyr::ungroup()

  bench <- ranks |>
    dplyr::group_by(year) |>
    dplyr::summarise(
      Top5  = mean(coverage_pct[in_top5],  na.rm = TRUE),
      Top10 = mean(coverage_pct[in_top10], na.rm = TRUE),
      Top50 = mean(coverage_pct[in_top50], na.rm = TRUE),
      .groups = "drop"
    ) |>
    tidyr::pivot_longer(cols = c("Top5", "Top10", "Top50"),
                        names_to = "benchmark", values_to = "coverage_pct") |>
    dplyr::mutate(
      benchmark = factor(benchmark, levels = c("Top50", "Top10", "Top5"))
    )

  # ---- Aesthetics ----
  col_donor <- "#0072BC"   # UNHCR blue
  col_top50 <- "#9E9E9E"   # darker grey
  col_top10 <- "#BDBDBD"   # medium grey
  col_top5  <- "#D9D9D9"   # lighter grey

  lty_top50 <- "dashed"
  lty_top10 <- "dotdash"
  lty_top5  <- "twodash"

  # ---- Titles ----
  year_range <- if (!is.null(start_year) && !is.null(end_year)) {
    paste0(start_year, "–", end_year)
  } else if (!is.null(start_year)) {
    paste0("from ", start_year)
  } else if (!is.null(end_year)) {
    paste0("through ", end_year)
  } else {
    "over time"
  }

 

  # ---- Plot ----
  p <- ggplot2::ggplot() +
    # Benchmarks (three straight lines, no points)
    ggplot2::geom_smooth(
      data = bench,
      ggplot2::aes(x = year, y = coverage_pct,
                   color = benchmark, linetype = benchmark),
      method = "loess", se = FALSE, span = loess_span,
      linewidth = 1.1
    ) +
    # Donor LOESS (replaces donor geom_line)
    { if (donor_exists)
        ggplot2::geom_smooth(
          data = donor_series,
          ggplot2::aes(x = year, y = coverage_pct),
          method = "loess", se = FALSE, span = loess_span,
          color = col_donor, linewidth = 1.8
        )
      else ggplot2::geom_blank() } +
    # Donor points
    { if (donor_exists)
        ggplot2::geom_point(
          data = donor_series,
          ggplot2::aes(x = year, y = coverage_pct),
          color = col_donor, size = 4.3, stroke = 0
        )
      else ggplot2::geom_blank() } +
    # Donor per-year labels: number of countries
    { if (donor_exists && !is.null(donor_labels_df) && nrow(donor_labels_df) > 0) {
        if (requireNamespace("ggrepel", quietly = TRUE)) {
          ggrepel::geom_label_repel(
            data = donor_labels_df,
            ggplot2::aes(x = year, y = coverage_pct, label = label_txt),
            color = col_donor,
            size = 7,
            direction = "y", max.overlaps = Inf,
            box.padding = 0.15, point.padding = 0.2,
            segment.color = col_donor, segment.size = 0.1,
            nudge_x = 0.01, hjust = 0
          )
        } else {
          ggplot2::geom_text(
            data = donor_labels_df,
            ggplot2::aes(x = year, y = coverage_pct, label = label_txt),
            color = col_donor, size = 3.8, vjust = -0.5
          )
        }
      } else ggplot2::geom_blank() } +
    ggplot2::scale_color_manual(
      values = c("Top50" = col_top50, "Top10" = col_top10, "Top5" = col_top5),
      labels = c("Top50" = "Top 50% donors (avg)",
                 "Top10" = "Top 10% donors (avg)",
                 "Top5"  = "Top 5% donors (avg)")
    ) +
    ggplot2::scale_linetype_manual(
      values = c("Top50" = lty_top50, "Top10" = lty_top10, "Top5" = lty_top5),
      labels = c("Top50" = "Top 50% donors (avg)",
                 "Top10" = "Top 10% donors (avg)",
                 "Top5"  = "Top 5% donors (avg)")
    ) +
    ggplot2::scale_y_continuous(
      labels = scales::percent,
      limits = c(0, 1),
      expand = ggplot2::expansion(mult = c(0, 0.05))
    ) +
    ggplot2::scale_x_continuous(breaks = scales::pretty_breaks()) +
    ggplot2::labs(
      title = paste0("Activity Diversification for ", donor_name),
    #  subtitle = paste(    "Donor’s % of UNHCR operations covered / Average coverage for Top 5%, Top 10%, and Top 50% donors (ranked by annual funding)" ),
      x = "Year",
      y = "% of UNHCR operations (countries) covered",
      color = NULL, linetype = NULL,
      caption = "Source: Data published by UNHCR as part of the International Aid Transparency Initiative (IATI)— Coverage = (# countries funded by donor) / (total distinct countries funded by any donor in year)."
    ) +
    unhcrthemes::theme_unhcr(grid = "Y", axis = "X", axis_title = FALSE, 
                             font_size = 20,
                             legend = TRUE,
                             legend_title = FALSE) +

    ggplot2::coord_cartesian(clip = "off")

  # ---- Verbose diagnostics ----
  if (verbose) {
    yrs <- range(df$year, na.rm = TRUE)
    message("Years covered: ", yrs[1], "–", yrs[2])
    message("Distinct donors in period: ", dplyr::n_distinct(df$transaction_provider_org))
    message("Distinct countries per year (min–max): ",
            min(total_countries_by_year$total_countries), "–",
            max(total_countries_by_year$total_countries))
  }

  return(p)
}

```

```{r example-show_donor_activity_diversification, message=FALSE, warning=FALSE, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center",  out.width = "90%"}
# Example usage:
show_donor_activity_diversification( 
  donor_name = "Private donors", 
   start_year = 2022, 
   end_year = 2025
)



```

```{r tests-show_donor_activity_diversification}
test_that("show_donor_activity_diversification works", {
  # Test with a specific donor and year range
  p_geo_div1 <- show_donor_activity_diversification(
        donor_name = "Private donors", 
         start_year = 2022, 
         end_year = 2025
  )
  expect_true(ggplot2::is_ggplot(p_geo_div1))
  
})
```

## show_donor_funding_volatility

```{r function-show_donor_funding_volatility}
#' Plot donor funding volatility
#'
#' @description
#' Creates a volatility view of a donor's incoming commitments:
#' - Points: transaction-level USD amounts for the selected donor
#' - Smoothed line: monthly/quarterly mean transaction value (donor)
#' - Comparator: weighted mean transaction value for other donors,
#'   weighted by each donor's total received amount (under the same filters)
#' - Forecast: simple trend model (lm on log1p period mean) extended forward
#'
#' Title/subtitle highlight average amount per transaction and average number of 
#' transactions per year for the donor vs weighted averages for other donors combined.
#'
#' @param donor_name Character. The donor to plot.
#' @param year Optional integer/numeric vector. Filter years (e.g., 2023 or c(2022,2023)).
#' @param programme_lab Optional character vector. Filter on programme label.
#' @param iati_identifier_ops Optional character vector. Filter on operation identifier.
#' @param ctr_name Optional character vector. Filter on recipient country name (ctr_name).
#' @param top_n_donors Optional integer. If provided, restricts comparator to
#'   the top N donors by total funding amount (USD) across the filtered period.
#'   NULL (default) includes all other donors in the comparator.
#' @param time_unit Aggregation unit for trend line: "month" (default) or "quarter".
#' @param smooth_method Smoother for trend line: "loess" (default) or "gam".
#' @param forecast_horizon Integer. Number of periods (months/quarters) to forecast.
#' @param show_forecast_ci Logical. If TRUE, show a confidence ribbon for the forecast.
#' @param verbose Logical. Print small diagnostics.
#'
#' @return A ggplot object.
#' @export
show_donor_funding_volatility <- function(donor_name,
                                          year = NULL,
                                          programme_lab = NULL,
                                          iati_identifier_ops = NULL,
                                          ctr_name = NULL,
                                          top_n_donors = NULL,
                                          time_unit = c("month", "quarter"),
                                          smooth_method = c("loess", "gam"),
                                          forecast_horizon = 6,
                                          show_forecast_ci = TRUE,
                                          verbose = TRUE) {

  time_unit <- match.arg(time_unit)
  smooth_method <- match.arg(smooth_method)

  # ---- 0) Load data ----
  tx  <- iati::dataTransaction
  act <- iati::dataActivity

  # value column (prefer USD)
  value_col <- dplyr::case_when(
    "transaction_value_USD" %in% names(tx) ~ "transaction_value_USD",
    TRUE ~ NA_character_
  )
  if (is.na(value_col)) stop("No transaction value column found (`transaction_value_USD` or `transaction_value`).")

  req_tx <- c("iati_identifier", "transaction_date", "transaction_provider_org",
              "transaction_type_name", value_col)
  missing_tx <- setdiff(req_tx, names(tx))
  if (length(missing_tx) > 0) {
    stop("Missing required columns in iati::dataTransaction: ", paste(missing_tx, collapse = ", "))
  }
  if (!("iati_identifier" %in% names(act))) stop("Missing `iati_identifier` in iati::dataActivity.")

  # ---- 1) Join + parse dates robustly ----
  df <- tx |>
    dplyr::left_join(act, by = "iati_identifier") |>
    dplyr::filter(transaction_type_name == "Incoming Commitment") |>
    dplyr::mutate(
      tx_date = as.Date(
        lubridate::parse_date_time(
          transaction_date,
          orders = c("ymd", "Ymd", "ymd HMS", "Ymd HMS", "ymd HM", "Ymd HM", "dmy", "mdy"),
          quiet = TRUE,
          tz = "UTC"
        )
      ),
      year_tx  = lubridate::year(tx_date),
      tx_value = as.numeric(.data[[value_col]])
    ) |>
    dplyr::filter(!is.na(tx_date), !is.na(year_tx), !is.na(tx_value))

  # ---- 2) Optional filters (vector-friendly + safe) ----
  year_filter      <- year
  programme_filter <- programme_lab
  ops_filter       <- iati_identifier_ops
  country_filter   <- ctr_name

  if (!is.null(year_filter)) {
    df <- df |> dplyr::filter(year_tx %in% .env$year_filter)
  }
  if (!is.null(programme_filter)) {
    if (!("programme_lab" %in% names(df))) stop("`programme_lab` column not found in joined data.")
    df <- df |> dplyr::filter(programme_lab %in% .env$programme_filter)
  } else if (!is.null(ops_filter)) {
    if (!("iati_identifier_ops" %in% names(df))) stop("`iati_identifier_ops` column not found in joined data.")
    df <- df |> dplyr::filter(iati_identifier_ops %in% .env$ops_filter)
  } else if (!is.null(country_filter)) {
    if (!("ctr_name" %in% names(df))) stop("`ctr_name` column not found in joined data.")
    df <- df |> dplyr::filter(ctr_name %in% .env$country_filter)
  }

  if (nrow(df) == 0) stop("No data available after filtering.")

  # ---- 3) Split donor vs others ----
  donor_df <- df |> dplyr::filter(transaction_provider_org == donor_name)
  if (nrow(donor_df) == 0) stop("Donor '", donor_name, "' not found under current filters.")
  others_df <- df |> dplyr::filter(transaction_provider_org != donor_name)

  # ---- 4) Apply top_n_donors filter to comparator if specified ----
  if (!is.null(top_n_donors)) {
    if (!is.numeric(top_n_donors) || top_n_donors < 1) {
      stop("top_n_donors must be a positive integer.")
    }
    
    # Calculate total funding per donor across all filtered years
    other_donor_totals <- others_df |>
      dplyr::group_by(transaction_provider_org) |>
      dplyr::summarise(
        total_funding = sum(tx_value, na.rm = TRUE),
        .groups = "drop"
      ) |>
      dplyr::arrange(dplyr::desc(total_funding)) |>
      dplyr::slice(1:top_n_donors)
    
    # Keep only top N donors for comparator
    top_comparator_donors <- other_donor_totals$transaction_provider_org
    
    # Filter others_df to include only top donors
    others_df <- others_df |>
      dplyr::filter(transaction_provider_org %in% top_comparator_donors)
    
    if (verbose) {
      message("Restricting comparator to top ", top_n_donors, 
              " other donors by total funding. Comparator donors: ",
              paste(top_comparator_donors, collapse = ", "))
    }
  }

  # ---- 5) Define time bucket ----
  bucket_unit <- if (time_unit == "month") "month" else "quarter"
  donor_df  <- donor_df  |> dplyr::mutate(period = lubridate::floor_date(tx_date, unit = bucket_unit))
  others_df <- others_df |> dplyr::mutate(period = lubridate::floor_date(tx_date, unit = bucket_unit))

  # ---- 6) Donor period summaries ----
  donor_period <- donor_df |>
    dplyr::group_by(period) |>
    dplyr::summarise(
      donor_total = sum(tx_value, na.rm = TRUE),
      donor_n     = dplyr::n(),
      donor_mean  = donor_total / donor_n,
      .groups = "drop"
    )

  # ---- 7) Weighted "other donors" period mean ----
  # Only calculate if there are other donors to compare with
  others_period <- NULL
  others_label <- "Other donors"
  
  if (nrow(others_df) > 0) {
    others_totals <- others_df |>
      dplyr::group_by(transaction_provider_org) |>
      dplyr::summarise(donor_total_all = sum(tx_value, na.rm = TRUE), .groups = "drop") |>
      dplyr::filter(donor_total_all > 0) |>
      dplyr::mutate(weight = donor_total_all / sum(donor_total_all, na.rm = TRUE))

    others_period_donor <- others_df |>
      dplyr::group_by(transaction_provider_org, period) |>
      dplyr::summarise(
        total = sum(tx_value, na.rm = TRUE),
        n     = dplyr::n(),
        mean  = total / n,
        .groups = "drop"
      ) |>
      dplyr::left_join(
        others_totals |> dplyr::select(transaction_provider_org, weight),
        by = "transaction_provider_org"
      )

    others_period <- others_period_donor |>
      dplyr::group_by(period) |>
      dplyr::summarise(
        others_weighted_mean = sum(mean * weight, na.rm = TRUE),
        .groups = "drop"
      )
    
    # Update label for comparator
    if (!is.null(top_n_donors)) {
      others_label <- paste0("Top ", top_n_donors, " other donors")
    }
  }

  # ---- 8) Forecast donor trend (lm on log1p of donor_mean) ----
  donor_period_model <- donor_period |>
    dplyr::arrange(period) |>
    dplyr::mutate(t = dplyr::row_number())

  forecast_df <- NULL
  if (nrow(donor_period_model) >= 4 && forecast_horizon > 0) {

    fit <- stats::lm(log1p(donor_mean) ~ t, data = donor_period_model)

    last_period <- max(donor_period_model$period)

    # ✅ No %m+%: use seq.Date (robust, base R)
    step_months <- if (time_unit == "month") 1 else 3
    future_periods <- seq.Date(
      from = last_period,
      by   = paste(step_months, "months"),
      length.out = forecast_horizon + 1
    )[-1]

    future_t <- max(donor_period_model$t) + seq_len(forecast_horizon)

    if (show_forecast_ci) {
      pred_ci <- stats::predict(fit, newdata = data.frame(t = future_t), interval = "confidence")
    
      # guard: ensure we can access columns by name
      pred_ci <- as.data.frame(pred_ci)
    
      forecast_df <- dplyr::tibble(
        period = future_periods,
        pred = expm1(pred_ci$fit),
        lwr  = expm1(pred_ci$lwr),
        upr  = expm1(pred_ci$upr)
      )
    } else {
      pred <- stats::predict(fit, newdata = data.frame(t = future_t))
      forecast_df <- dplyr::tibble(
        period = future_periods,
        pred = expm1(as.numeric(pred))
      )
    }

  }

  # ---- 9) KPI text for title/subtitle ----
  donor_avg_txn <- mean(donor_df$tx_value, na.rm = TRUE)
  donor_n_txn   <- nrow(donor_df)
  donor_years   <- length(unique(donor_df$year_tx))
  donor_txn_per_year <- donor_n_txn / max(donor_years, 1)

  # Calculate comparator KPIs if comparator exists
  others_weighted_avg_txn <- NA
  others_weighted_txn_per_year <- NA
  comparator_available <- FALSE
  
  if (!is.null(others_period) && nrow(others_df) > 0) {
    comparator_available <- TRUE
    
    # Calculate weighted average transactions per year for other donors
    others_kpi <- others_df |>
      dplyr::group_by(transaction_provider_org) |>
      dplyr::summarise(
        total = sum(tx_value, na.rm = TRUE),
        n = dplyr::n(),
        avg_txn = total / n,
        years = dplyr::n_distinct(year_tx),
        txn_per_year = n / pmax(years, 1),
        .groups = "drop"
      ) |>
      dplyr::filter(total > 0) |>
      dplyr::mutate(w = total / sum(total, na.rm = TRUE))

    others_weighted_avg_txn <- sum(others_kpi$avg_txn * others_kpi$w, na.rm = TRUE)
    others_weighted_txn_per_year <- sum(others_kpi$txn_per_year * others_kpi$w, na.rm = TRUE)
  }

  fmt_money <- scales::label_number(scale_cut = scales::cut_short_scale(), accuracy = 0.1)
  fmt_num   <- scales::label_number(accuracy = 0.1)

  title <- paste0("Funding Volatility for ", donor_name,  " (",
      fmt_money(donor_avg_txn),  "$ Average Transaction Amount through ", 
      fmt_num(donor_txn_per_year), " Avg. # of Transactions/Year). ",
    if (!is.null(country_filter)) paste0("| Commitments to  ", paste(country_filter, collapse = ", ")) else "")
  
  # Build subtitle based on comparator availability
  if (comparator_available) {
    subtitle <- paste0(
      fmt_money(donor_avg_txn),  "$ Average Transaction Amount through ", 
      fmt_num(donor_txn_per_year), " Avg. Transactions per Year  (Benchmark ", 
      others_label, ":  ", fmt_money(others_weighted_avg_txn),
      "$ Average Transaction Amount through ", fmt_num(others_weighted_txn_per_year), " Avg. Transactions per Year)"
    )
  } else {
    subtitle <- paste0(
      fmt_money(donor_avg_txn),  "$ Average Transaction Amount through ", 
      fmt_num(donor_txn_per_year), " Avg. Transactions per Year  (No comparator data available)"
    )
  }

  # ---- 10) Plot ----
  col_donor    <- "#0072BC"
  col_others   <- "#6B6E70"
  col_forecast <- "#F28E2B"

  p <- ggplot2::ggplot() +
    # Selected donor: individual transaction points
    ggplot2::geom_point(
      data = donor_df,
      ggplot2::aes(x = tx_date, y = tx_value),
      color = col_donor,
      alpha = 0.25,
      size = 1.5
    ) +
    # Selected donor: period mean line
    ggplot2::geom_line(
      data = donor_period,
      ggplot2::aes(x = period, y = donor_mean),
      color = col_donor,
      linewidth = 1
    ) +
    # Selected donor: smoothed trend line
    ggplot2::geom_smooth(
      data = donor_period,
      ggplot2::aes(x = period, y = donor_mean),
      method  = if (smooth_method == "loess") "loess" else "gam",
      formula = if (smooth_method == "loess") y ~ x else y ~ s(x, bs = "cs"),
      se = FALSE,
      color = col_donor,
      linewidth = 1,
      linetype = "solid",
      alpha = 0.15
    ) +
    # Other donors: weighted mean trend line (NO individual points)
    { if (!is.null(others_period) && nrow(others_period) > 0)
      ggplot2::geom_line(
        data = others_period,
        ggplot2::aes(x = period, y = others_weighted_mean),
        color = col_others,
        linewidth = 1,
        linetype = "dotdash"
      )
    } +
    { if (!is.null(forecast_df) && show_forecast_ci)
      ggplot2::geom_ribbon(
        data = forecast_df,
        ggplot2::aes(x = period, ymin = lwr, ymax = upr),
        fill = col_forecast,
        alpha = 0.15
      )
    } +
    { if (!is.null(forecast_df))
      ggplot2::geom_line(
        data = forecast_df,
        ggplot2::aes(x = period, y = pred),
        color = col_forecast,
        linewidth = 1,
        linetype = "dashed"
      )
    } +
    ggplot2::scale_y_continuous(labels = scales::label_number(scale_cut = scales::cut_short_scale())) +
    ggplot2::labs(
      title = title,
      subtitle = subtitle,
      x = "Transaction date",
      y = "Transaction value (USD)",
      caption = paste0(
        "Blue points: donor transactions. Blue line: donor period mean (", time_unit,
        "). Grey dashed line: weighted ", tolower(others_label), " mean. ",
        if (!is.null(forecast_df)) "Dashed orange: simple trend forecast. " else "",
        "\nSource: Data published by UNHCR as part of the International Aid Transparency Initiative (IATI)"
      )     
    ) +
    unhcrthemes::theme_unhcr(grid = "Y", axis = "X", axis_title = "X", 
                             font_size = 20)

  if (verbose) {
    message(
      "Volatility plot prepared for donor: ", donor_name,
      " | periods: ", nrow(donor_period),
      " | comparator: ", ifelse(is.null(others_period) || nrow(others_period) == 0, "none", others_label),
      " | forecast: ", ifelse(is.null(forecast_df), "none", paste0(nrow(forecast_df), " periods"))
    )
  }

  p
}
```

```{r example-show_donor_funding_volatility, message=FALSE, warning=FALSE, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center",  out.width = "90%"}
# Donor Funding Volatility

show_donor_funding_volatility(
  donor_name = "Private donors",
  time_unit = "quarter",
  forecast_horizon = 8
)

show_donor_funding_volatility(
  donor_name = "Private donors",
  year = 2022:2026,
  top_n_donors = 10,,
  forecast_horizon = 8,
  time_unit = "month"
)

show_donor_funding_volatility(donor_name = "Private donors", 
                              ctr_name = "Brazil")
```

  
```{r tests-show_donor_funding_volatility}
test_that("show_donor_funding_volatility works", {
  expect_true(inherits(show_donor_funding_volatility, "function")) 
})
```  




```{r development-inflate, eval=FALSE}
# Inflate the package

# You're one inflate from paper to box.
# Build your package from this very Rmd using `fusen::inflate()`
# 
# - Verify your `"DESCRIPTION"` file has been updated
# - Verify your function is in `"R/"` directory
# - Verify your test is in `"tests/testthat/"` directory
# - Verify this Rmd appears in `"vignettes/"` directory

# Keep eval=FALSE to avoid infinite loop in case you hit the knit button
# Execute in the console directly
fusen::inflate(flat_file = "dev/dev_donor_focus.Rmd", clean=TRUE, vignette_name = "-- Donor Analysis")
```