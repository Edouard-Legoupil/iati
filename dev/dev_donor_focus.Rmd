---
title: "IATI Visualisation"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r developmenttest, include=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message=FALSE, 
  warning=FALSE,
  fig.width = 8,
  fig.asp = 0.718,
  out.width = "90%"
)
library(testthat) 
library(ggplot2)
library(dplyr)
# Load already included functions
pkgload::load_all(export_all = FALSE)
```

## show_donor_ranking

```{r function-show_donor_ranking}
#' Donor ranking by funding volume (lollipop) with optional WB population/GDP weighting
#'
#' @description
#' - If multiple years are provided, shows donors as rows and yearly points colored by year.
#' - If a single year is provided, shows donor totals as stems with points by earmarking category.
#' - If `weight_by != "none"`, population/GDP are pulled from the World Bank using {worldbank}
#'   and only donors that can be matched to a WB country are displayed.
#'
#' @param donor_name Optional donor to highlight.
#' @param top_n_display Number of top donors to display (selected by reference year = max(year)).
#' @param year NULL (defaults to latest), single year, or vector of years.
#' @param ctr_name Optional recipient country filter (from iati::dataActivity$ctr_name).
#' @param weight_by One of "none", "population", "gdp", "population_gdp".
#' @param donor_country_map Optional named character vector mapping donor org -> WB country name
#'   (names are donor org strings; values are WB country names). Use when donor names don't match countries.
#' @param wb_lang Language for WB API queries (default "en").
#' @param top_n_earmarking In single-year earmarking mode: keep top N earmarking categories overall, rest "Other".
#' @param verbose Print helpful messages.
#'
#' @return ggplot object
#' @export
show_donor_ranking <- function(donor_name = NULL,
                               top_n_display = 10,
                               year = NULL,
                               ctr_name = NULL,
                               weight_by = c("none", "population", "gdp", "population_gdp"),
                               donor_country_map = NULL,
                               wb_lang = "en",
                               top_n_earmarking = 8,
                               verbose = TRUE) {

  weight_by <- match.arg(weight_by)

  # ---- Packages used ----
  # Requires: dplyr, ggplot2, lubridate, forcats, scales, unhcrthemes, worldbank, tidyr, stringr

  # ---- 0) Basic checks ----
  if (!is.numeric(top_n_display) || length(top_n_display) != 1 || top_n_display < 1) {
    stop("`top_n_display` must be a single integer >= 1.")
  }
  if (!is.numeric(top_n_earmarking) || length(top_n_earmarking) != 1 || top_n_earmarking < 1) {
    stop("`top_n_earmarking` must be a single integer >= 1.")
  }

  # ---- 1) Get IATI data ----
  data_transaction <- iati::dataTransaction
  data_activity    <- iati::dataActivity

  # pick value column (prefer USD)
  value_col <- dplyr::case_when(
    "transaction_value_USD" %in% names(data_transaction) ~ "transaction_value_USD",
    "transaction_value"     %in% names(data_transaction) ~ "transaction_value",
    TRUE ~ NA_character_
  )
  if (is.na(value_col)) stop("Missing transaction value column (`transaction_value_USD` or `transaction_value`).")

  # parse year(s)
  years_requested <- year
  if (!is.null(years_requested)) {
    years_requested <- as.integer(years_requested)
    years_requested <- years_requested[!is.na(years_requested)]
    if (length(years_requested) == 0) years_requested <- NULL
  }
  multi_year <- !is.null(years_requested) && length(years_requested) > 1

  # ---- 2) Filter + parse dates robustly ----
  df <- data_transaction |>
    dplyr::filter(.data$transaction_type_name == "Incoming Commitment") |>
    dplyr::mutate(
      tx_date = as.Date(
        lubridate::parse_date_time(
          .data$transaction_date,
          orders = c("ymd", "Ymd", "ymd HMS", "Ymd HMS", "ymd HM", "Ymd HM", "dmy", "mdy"),
          quiet = TRUE,
          tz = "UTC"
        )
      ),
      year_tx = lubridate::year(.data$tx_date),
      tx_value = as.numeric(.data[[value_col]])
    ) |>
    dplyr::filter(!is.na(.data$year_tx), !is.na(.data$tx_value))

  # join activity for recipient country + earmarking (if present)
  act_cols <- intersect(c("iati_identifier", "ctr_name", "earmarking_name"), names(data_activity))
  df <- df |>
    dplyr::left_join(data_activity |> dplyr::select(dplyr::all_of(act_cols)), by = "iati_identifier")

  if (!is.null(ctr_name)) {
    if (!("ctr_name" %in% names(df))) stop("ctr_name filter requested but `ctr_name` not found after join.")
    df <- df |> dplyr::filter(.data$ctr_name %in% .env$ctr_name)
  }

  # determine years_to_plot
  available_years <- sort(unique(df$year_tx))
  if (length(available_years) == 0) stop("No usable transactions after filtering.")

  if (is.null(years_requested)) {
    years_to_plot <- max(available_years, na.rm = TRUE)
    if (verbose) message("No year provided. Using latest year: ", years_to_plot)
  } else {
    missing <- setdiff(years_requested, available_years)
    if (length(missing) > 0) stop("Year(s) not found in data: ", paste(missing, collapse = ", "))
    years_to_plot <- years_requested
  }

  ref_year <- max(years_to_plot, na.rm = TRUE)

  # ---- 3) Aggregate donor totals per year (for ranking selection) ----
  donor_totals_ref <- df |>
    dplyr::filter(.data$year_tx == ref_year) |>
    dplyr::group_by(.data$transaction_provider_org) |>
    dplyr::summarise(total_ref = sum(.data$tx_value, na.rm = TRUE), .groups = "drop")

  if (nrow(donor_totals_ref) == 0) stop("No data for reference year: ", ref_year)

  top_donors <- donor_totals_ref |>
    dplyr::arrange(dplyr::desc(.data$total_ref)) |>
    dplyr::slice_head(n = top_n_display) |>
    dplyr::pull(.data$transaction_provider_org) |>
    as.character()

  if (!is.null(donor_name)) {
    donor_name <- as.character(donor_name)
    if (!donor_name %in% donor_totals_ref$transaction_provider_org) {
      stop("Donor '", donor_name, "' not found in data for year ", ref_year, ".")
    }
    if (!donor_name %in% top_donors) top_donors <- unique(c(top_donors, donor_name))
  }

  df <- df |>
    dplyr::filter(.data$transaction_provider_org %in% .env$top_donors,
                  .data$year_tx %in% .env$years_to_plot)

  # ---- 4) World Bank weights (population / GDP) if requested ----
  wb_weights <- NULL
  if (weight_by != "none") {

    # Map donor -> country name used for WB matching
    donors <- unique(df$transaction_provider_org)

    donor_country <- if (!is.null(donor_country_map)) {
      # donor_country_map: named vector (donor org -> WB country name)
      mapped <- donor_country_map[names(donor_country_map) %in% donors]
      dplyr::tibble(
        transaction_provider_org = names(mapped),
        country_name = as.character(mapped)
      )
    } else {
      # try direct match donor name == country name
      dplyr::tibble(
        transaction_provider_org = donors,
        country_name = donors
      )
    }

    # WB country metadata to get ISO3 codes
    wb_countries <- worldbank::wb_country(lang = wb_lang)  # provides country_code (iso3) + country_name etc. [5](https://github.com/m-muecke/worldbank)

    donor_country <- donor_country |>
      dplyr::left_join(
        wb_countries |> dplyr::select(country_code, country_name),
        by = "country_name"
      ) |>
      dplyr::filter(!is.na(.data$country_code))

    if (nrow(donor_country) == 0) {
      stop("weight_by != 'none': No donors could be matched to a World Bank country. Provide `donor_country_map`.")
    }

    # pull indicators from WB for the requested years
    # wb_data() supports indicator, country, start_date, end_date [1](https://m-muecke.github.io/worldbank/reference/wb_data.html)
    ind <- c(pop = "SP.POP.TOTL", gdp = "NY.GDP.MKTP.CD")

    wb_raw <- worldbank::wb_data(
      indicator  = unname(ind),
      country    = unique(donor_country$country_code),
      lang       = wb_lang,
      start_date = min(years_to_plot),
      end_date   = max(years_to_plot)
    )

    # reshape to wide: one row per (country_code, date)
    wb_wide <- wb_raw |>
      dplyr::mutate(date = as.integer(.data$date)) |>
      dplyr::select(.data$country_code, .data$date, .data$indicator_id, .data$value) |>
      tidyr::pivot_wider(names_from = .data$indicator_id, values_from = .data$value)

    # join back to donor org and rename columns
    wb_weights <- donor_country |>
      dplyr::select(.data$transaction_provider_org, .data$country_code, .data$country_name) |>
      dplyr::left_join(wb_wide, by = "country_code") |>
      dplyr::rename(
        year_wb = .data$date,
        population = .data$`SP.POP.TOTL`,
        gdp = .data$`NY.GDP.MKTP.CD`
      ) |>
      dplyr::filter(.data$year_wb %in% .env$years_to_plot)

    # keep only donors with valid weights
    wb_weights <- wb_weights |>
      dplyr::filter(
        !is.na(.data$population) | weight_by == "gdp",
        !is.na(.data$gdp) | weight_by == "population"
      )

    if (nrow(wb_weights) == 0) {
      stop("No WB population/GDP found for matched donors in the selected years.")
    }

    # requirement: "display only donor matching a country" when weighted
    df <- df |>
      dplyr::inner_join(
        wb_weights |> dplyr::select(.data$transaction_provider_org) |> dplyr::distinct(),
        by = "transaction_provider_org"
      )
  }

  # ---- 5) Define metric (total vs weighted) ----
  # weight_by:
  # - population: USD per person
  # - gdp: USD per USD GDP (share of GDP, dimensionless)
  # - population_gdp: USD per (person * USD GDP) rescaled for readability
  metric_info <- list()

  compute_metric <- function(total_funding, pop, gdp, weight_by) {
    if (weight_by == "none") return(total_funding)
    if (weight_by == "population") return(total_funding / pop)
    if (weight_by == "gdp") return(total_funding / gdp)
    if (weight_by == "population_gdp") {
      # rescale: USD / ((pop/1e6)*(gdp/1e9)) = USD * 1e15 / (pop*gdp)
      return(total_funding * 1e15 / (pop * gdp))
    }
    total_funding
  }

  metric_info$title <- if (weight_by == "none") "Total funding"
  else if (weight_by == "population") "Funding per person"
  else if (weight_by == "gdp") "Funding as share of GDP"
  else "Funding per (1M people × 1B GDP) (rescaled)"

  metric_info$subtitle_suffix <- if (weight_by == "none") {
    "Metric = total funding (USD)."
  } else if (weight_by == "population") {
    "Metric = funding per person (USD/person) using World Bank population."
  } else if (weight_by == "gdp") {
    "Metric = funding / GDP (USD/USD) using World Bank GDP (current US$)."
  } else {
    "Metric = USD per (1M people × 1B GDP), rescaled (×1e15) using World Bank population & GDP."
  }

  # ---- 6) MULTI-YEAR: points by year (colored) ----
  if (multi_year) {

    df_year <- df |>
      dplyr::group_by(.data$transaction_provider_org, .data$year_tx) |>
      dplyr::summarise(total_funding = sum(.data$tx_value, na.rm = TRUE), .groups = "drop")

    if (weight_by != "none") {
      df_year <- df_year |>
        dplyr::left_join(
          wb_weights |> dplyr::rename(year_tx = .data$year_wb) |>
            dplyr::select(.data$transaction_provider_org, .data$year_tx, .data$population, .data$gdp),
          by = c("transaction_provider_org", "year_tx")
        ) |>
        dplyr::filter(!(is.na(.data$population) & weight_by %in% c("population", "population_gdp")),
                      !(is.na(.data$gdp) & weight_by %in% c("gdp", "population_gdp"))) |>
        dplyr::mutate(metric_value = compute_metric(.data$total_funding, .data$population, .data$gdp, weight_by))
    } else {
      df_year <- df_year |>
        dplyr::mutate(metric_value = .data$total_funding)
    }

    # order by ref year
    ref_order <- df_year |>
      dplyr::filter(.data$year_tx == ref_year) |>
      dplyr::arrange(.data$metric_value) |>
      dplyr::pull(.data$transaction_provider_org) |>
      as.character()

    df_year <- df_year |>
      dplyr::mutate(
        donor = factor(.data$transaction_provider_org, levels = ref_order),
        year_f = factor(.data$year_tx, levels = sort(unique(.data$year_tx))),
        highlight = if (is.null(donor_name)) "No" else ifelse(.data$transaction_provider_org == donor_name, "Yes", "No")
      )

    df_ranges <- df_year |>
      dplyr::group_by(.data$donor) |>
      dplyr::summarise(
        xmin = min(.data$metric_value, na.rm = TRUE),
        xmax = max(.data$metric_value, na.rm = TRUE),
        .groups = "drop"
      )

    title <- paste0(
      "Donor ranking trajectory (", min(years_to_plot), "–", max(years_to_plot), ")",
      if (!is.null(ctr_name)) paste0(" — ", paste(ctr_name, collapse = ", ")) else ""
    )

    subtitle <- paste0(
      "Top ", top_n_display, " donors (selected by ", ref_year, "). ",
      "Points are annual values; color indicates year. ",
      metric_info$subtitle_suffix
    )

    p <- ggplot2::ggplot(df_year, ggplot2::aes(y = .data$donor, x = .data$metric_value)) +
      ggplot2::geom_segment(
        data = df_ranges,
        ggplot2::aes(y = .data$donor, yend = .data$donor, x = .data$xmin, xend = .data$xmax),
        inherit.aes = FALSE,
        linewidth = 1,
        color = "#B9C2CB"
      ) +
      ggplot2::geom_point(ggplot2::aes(color = .data$year_f), size = 3.8) +
      ggplot2::geom_point(
        data = dplyr::filter(df_year, .data$highlight == "Yes"),
        ggplot2::aes(color = .data$year_f),
        size = 5.2
      ) +
      ggplot2::scale_color_brewer(palette = "Set1", name = "Year") +
      ggplot2::scale_x_continuous(labels = scales::label_number(scale_cut = scales::cut_short_scale())) +
      unhcrthemes::theme_unhcr(grid = "X", axis = "Y", axis_title = FALSE, font_size = 18) +
      ggplot2::labs(title = title, subtitle = subtitle, x = metric_info$title, y = NULL,
                    caption = "Source: Data published by UNHCR as part of the International Aid Transparency Initiative (IATI)")

    return(p)
  }

  # ---- 7) SINGLE YEAR: points by earmarking category ----
  year_single <- years_to_plot[[1]]

  if (!("earmarking_name" %in% names(df))) {
    stop("Single-year earmarking mode requires `earmarking_name` in iati::dataActivity.")
  }

  df_earm <- df |>
    dplyr::filter(.data$year_tx == year_single, !is.na(.data$earmarking_name)) |>
    dplyr::group_by(.data$transaction_provider_org, .data$earmarking_name) |>
    dplyr::summarise(total_funding = sum(.data$tx_value, na.rm = TRUE), .groups = "drop")

  # top N earmarking + Other
  top_earm <- df_earm |>
    dplyr::group_by(.data$earmarking_name) |>
    dplyr::summarise(v = sum(.data$total_funding, na.rm = TRUE), .groups = "drop") |>
    dplyr::arrange(dplyr::desc(.data$v)) |>
    dplyr::slice_head(n = top_n_earmarking) |>
    dplyr::pull(.data$earmarking_name) |>
    as.character()

  df_earm <- df_earm |>
    dplyr::mutate(
      earmarking_grp = ifelse(.data$earmarking_name %in% top_earm, as.character(.data$earmarking_name), "Other")
    ) |>
    dplyr::group_by(.data$transaction_provider_org, .data$earmarking_grp) |>
    dplyr::summarise(total_funding = sum(.data$total_funding, na.rm = TRUE), .groups = "drop")

  df_tot <- df_earm |>
    dplyr::group_by(.data$transaction_provider_org) |>
    dplyr::summarise(total = sum(.data$total_funding, na.rm = TRUE), .groups = "drop")

  if (weight_by != "none") {
    wb_y <- wb_weights |>
      dplyr::rename(year_tx = .data$year_wb) |>
      dplyr::filter(.data$year_tx == year_single) |>
      dplyr::select(.data$transaction_provider_org, .data$population, .data$gdp)

    df_tot <- df_tot |>
      dplyr::left_join(wb_y, by = "transaction_provider_org") |>
      dplyr::mutate(total = compute_metric(.data$total, .data$population, .data$gdp, weight_by))

    df_earm <- df_earm |>
      dplyr::left_join(wb_y, by = "transaction_provider_org") |>
      dplyr::mutate(total_funding = compute_metric(.data$total_funding, .data$population, .data$gdp, weight_by)) |>
      dplyr::select(-.data$population, -.data$gdp)
  }

  # order donors by total
  order_levels <- df_tot |>
    dplyr::arrange(.data$total) |>
    dplyr::pull(.data$transaction_provider_org) |>
    as.character()

  df_tot <- df_tot |>
    dplyr::mutate(donor = factor(.data$transaction_provider_org, levels = order_levels))

  df_earm <- df_earm |>
    dplyr::mutate(
      donor = factor(.data$transaction_provider_org, levels = order_levels),
      highlight = if (is.null(donor_name)) "No" else ifelse(.data$transaction_provider_org == donor_name, "Yes", "No")
    )

  title <- paste0(
    "Donor ranking (", year_single, ")",
    if (!is.null(ctr_name)) paste0(" — ", paste(ctr_name, collapse = ", ")) else ""
  )

  subtitle <- paste0(
    "Top ", top_n_display, " donors. Grey line shows donor total; points show earmarking categories (top ",
    top_n_earmarking, " + Other). ",
    metric_info$subtitle_suffix,
    if (!is.null(donor_name)) paste0(" Highlighted: ", donor_name, ".") else ""
  )

  p <- ggplot2::ggplot(df_earm, ggplot2::aes(y = .data$donor, x = .data$total_funding)) +
    ggplot2::geom_segment(
      data = df_tot,
      ggplot2::aes(y = .data$donor, yend = .data$donor, x = 0, xend = .data$total),
      inherit.aes = FALSE,
      linewidth = 1,
      color = "#B9C2CB"
    ) +
    ggplot2::geom_point(ggplot2::aes(color = .data$earmarking_grp), size = 3.6, alpha = 0.95) +
    ggplot2::geom_point(
      data = dplyr::filter(df_earm, .data$highlight == "Yes"),
      ggplot2::aes(color = .data$earmarking_grp),
      size = 5.0
    ) +
    ggplot2::scale_color_brewer(palette = "Set2", name = "Earmarking") +
    ggplot2::scale_x_continuous(labels = scales::label_number(scale_cut = scales::cut_short_scale())) +
    unhcrthemes::theme_unhcr(grid = "X", axis = "Y", axis_title = FALSE, font_size = 18) +
    ggplot2::labs(title = title, subtitle = subtitle, x = metric_info$title, y = NULL,
                  caption = "Source: Data published by UNHCR as part of the International Aid Transparency Initiative (IATI)")

  p
}


```

```{r example-show_donor_ranking}
# Example usage:
show_donor_ranking(  
   year = 2025,
   top_n_display = 20 )

show_donor_ranking(
  donor_name = "Private donors",
  year = c(2023,2024,2025),
  top_n_display = 10
)

show_donor_ranking(   donor_name = "Private donors", 
   year = 2023,
   top_n_display = 10 )


```

```{r tests-show_donor_ranking}
test_that("show_donor_ranking works", {
  
  # Test with a specific donor and year
  p_rank1 <- show_donor_ranking( donor_name = "Private donors", 
    year = 2023,
    top_n_display = 10
  )
  expect_true(ggplot2::is.ggplot(p_rank1))
})
```


## show_donor_funding_over_time
    
```{r function-show_donor_funding_over_time}

#' Plot donor funding over time (bar chart)
#'
#' @description
#' This function plots the funding from a specific donor over time as a bar chart.
#' If `by` is not "global", the plot is faceted by the corresponding `by` variable.
#'
#' @param donor_name The name of the donor to plot.
#' @param year A numeric value or a vector of numeric values to filter on year.
#' @param by The category to group by. One of "global", "region", "country", "earmarking_name".
#' @param programme_lab A character vector corresponding to the name of the programme.
#' @param iati_identifier_ops A character vector corresponding to the name of the operation.
#' @param ctr_name A character vector corresponding to the name of the country.
#' @param top_n_countries The number of top countries to show when `by = "country"`.
#'
#' @import ggplot2
#' @import dplyr
#' @import scales
#' @import unhcrthemes
#'
#' @export
show_donor_funding_over_time <- function(donor_name,
                                         year = NULL,
                                         by = "global",
                                         programme_lab = NULL,
                                         iati_identifier_ops = NULL,
                                         ctr_name = NULL,
                                         top_n_countries = 10) {

  # Basic data preparation
  df <- iati::dataTransaction |>
    dplyr::left_join(iati::dataActivity, by = "iati_identifier") |>
    dplyr::filter(
      .data$transaction_provider_org == donor_name,
      .data$transaction_type_name == "Incoming Commitment"
    )

  # Filtering (vector-friendly)
  if (!is.null(year)) {
    df <- df |> dplyr::filter(.data$year %in% year)
  }
  if (!is.null(programme_lab)) {
    df <- df |> dplyr::filter(.data$programme_lab %in% programme_lab)
  } else if (!is.null(iati_identifier_ops)) {
    df <- df |> dplyr::filter(.data$iati_identifier_ops %in% iati_identifier_ops)
  } else if (!is.null(ctr_name)) {
    df <- df |> dplyr::filter(.data$ctr_name %in% ctr_name)
  }

  # Ensure year is an ordered factor (nice bar ordering) - robust to char/numeric
  df <- df |>
    dplyr::mutate(
      year = suppressWarnings(as.numeric(as.character(.data$year))),
      year = factor(year, levels = sort(unique(year), na.last = TRUE))
    )

  # Determine grouping variable (for faceting when by != global)
  facet_var <- switch(
    by,
    "global" = NULL,
    "region" = "unhcr_region",
    "country" = "ctr_name",
    "earmarking_name" = "earmarking_name",
    stop("Invalid 'by' argument. Choose from 'global', 'region', 'country', 'earmarking_name'.")
  )

  # If by == region: map missing/empty region to "global/HQ"
  if (identical(by, "region")) {
    df <- df |>
      dplyr::mutate(
        unhcr_region = dplyr::case_when(
          is.na(.data$unhcr_region) ~ "global/HQ",
          trimws(.data$unhcr_region) == "" ~ "global/HQ",
          TRUE ~ .data$unhcr_region
        )
      )
  }

  # If by == country: keep only top N countries overall (across years)
  if (identical(by, "country")) {
    top_countries <- df |>
      dplyr::group_by(.data$ctr_name) |>
      dplyr::summarise(
        total = sum(.data$transaction_value_USD, na.rm = TRUE),
        .groups = "drop"
      ) |>
      dplyr::slice_max(order_by = .data$total, n = top_n_countries, with_ties = FALSE) |>
      dplyr::pull(.data$ctr_name)

    df <- df |> dplyr::filter(.data$ctr_name %in% top_countries)
  }

  # Drop NA levels for facet var (after any mapping above)
  if (!is.null(facet_var)) {
    df <- df |> dplyr::filter(!is.na(.data[[facet_var]]))
  }

  # Summarise
  if (is.null(facet_var)) {
    show_data <- df |>
      dplyr::group_by(.data$year) |>
      dplyr::summarise(
        total_funding = sum(.data$transaction_value_USD, na.rm = TRUE),
        .groups = "drop"
      )
  } else {
    show_data <- df |>
      dplyr::group_by(.data$year, .data[[facet_var]]) |>
      dplyr::summarise(
        total_funding = sum(.data$transaction_value_USD, na.rm = TRUE),
        .groups = "drop"
      )
  }

  # Subtitle logic (mentions top_n_countries when by == "country")
  subtitle_txt <- if (is.null(facet_var)) {
    "Overall (Global)"
  } else if (identical(by, "country")) {
    paste0("Grouped by country — top ", top_n_countries, " countries")
  } else {
    paste("Grouped by", by)
  }

  # Plot (bar chart only)
  p <- ggplot2::ggplot(show_data, ggplot2::aes(x = .data$year, y = .data$total_funding)) +
    ggplot2::geom_col(fill = "#0072BC") +
    unhcrthemes::theme_unhcr(grid = "Y", axis = "X", axis_title = "X") +
    ggplot2::scale_y_continuous(labels = scales::label_number(scale_cut = scales::cut_short_scale())) +
    ggplot2::labs(
      title = paste("Funding Over Time from", donor_name),
      subtitle = subtitle_txt,
      x = "Year",
      y = "Total Funding (USD)",
      caption = "Source: Data published by UNHCR as part of the International Aid Transparency Initiative (IATI)"
    )

  # Facet if not global
  if (!is.null(facet_var)) {
    p <- p + ggplot2::facet_wrap(stats::as.formula(paste("~", facet_var)))
  }

  p
}

```

```{r example-show_donor_funding_over_time, message=FALSE, warning=FALSE, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center",  out.width = "90%"}
show_donor_funding_over_time(donor_name = "Private donors",
                                         year = c(2022, 2023, 20234, 2025),
                                         by = "global" )
show_donor_funding_over_time(donor_name = "Private donors",
                                         year = c(2022, 2023, 20234, 2025),
                                         by = "region" )
show_donor_funding_over_time(donor_name = "Private donors",
                                         year = c(2022, 2023, 20234, 2025),
                                         by = "earmarking_name" )
show_donor_funding_over_time(donor_name = "Private donors",
                                         year = c(2022, 2023, 20234, 2025),
                                         by = "country",
                                         top_n_countries = 10)

```
  
```{r tests-show_donor_funding_over_time}
test_that("show_donor_funding_over_time works", {
  expect_true(inherits(show_donor_funding_over_time, "function")) 
})
```

## show_donor_earmarking

```{r function-show_donor_earmarking}
#' Plot earmarking composition for a donor (stacked bar chart)
#'
#' @description
#' This function plots the earmarking composition of incoming commitments for a donor.
#' Depending on `by`, it shows a single global bar chart, bars by year, or stacked bars by
#' region/country/sector. All bar charts are ordered by total descending amount, except
#' for date grouping which is ordered chronologically.
#'
#' @param donor_name The name of the donor to plot.
#' @param year A numeric value or a vector of numeric values to filter on year.
#' @param by Grouping dimension: one of "global", "date", "region", "country", "sector".
#' @param programme_lab A character vector of programme labels to filter on.
#' @param iati_identifier_ops A character vector of operation identifiers to filter on.
#' @param ctr_name A character vector of country names to filter on.
#'
#' @import ggplot2
#' @import dplyr
#' @import scales
#' @import unhcrthemes
#'
#' @export
show_donor_earmarking <- function(donor_name,
                                  year = NULL,
                                  by = c("global", "date", "region", "country", "sector"),
                                  programme_lab = NULL,
                                  iati_identifier_ops = NULL,
                                  ctr_name = NULL) {

  by <- match.arg(by)

  # keep filters in separate objects to avoid name collision with column names
  year_filter <- year
  programme_filter <- programme_lab
  ops_filter <- iati_identifier_ops
  country_filter <- ctr_name

  # Basic data preparation
  df <- iati::dataTransaction |>
    dplyr::left_join(iati::dataActivity, by = "iati_identifier") |>
    dplyr::filter(
      transaction_provider_org == donor_name,
      transaction_type_name == "Incoming Commitment"
    )

  # Filtering (vector-friendly + safe evaluation)
  if (!is.null(year_filter)) {
    df <- df |> dplyr::filter(.data$year %in% .env$year_filter)
  }
  if (!is.null(programme_filter)) {
    df <- df |> dplyr::filter(.data$programme_lab %in% .env$programme_filter)
  } else if (!is.null(ops_filter)) {
    df <- df |> dplyr::filter(.data$iati_identifier_ops %in% .env$ops_filter)
  } else if (!is.null(country_filter)) {
    df <- df |> dplyr::filter(.data$ctr_name %in% .env$country_filter)
  }

  # Calculate total funding for the title
  total_funding_amount <- sum(df$transaction_value_USD, na.rm = TRUE)
  
  # Format total funding for display
  formatted_total <- scales::label_number(
    scale_cut = scales::cut_short_scale(),
    accuracy = 0.1
  )(total_funding_amount)
  
  # Build show_data with a single x column, depending on `by`
  show_data <- switch(
    by,

    "global" = {
      df |>
        dplyr::filter(!is.na(.data$earmarking_name)) |>
        dplyr::group_by(.data$earmarking_name) |>
        dplyr::summarise(
          total_funding = sum(.data$transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::arrange(dplyr::desc(total_funding)) |>
        dplyr::mutate(x = "Global")
    },

    "date" = {
      # For date grouping, order by date chronologically
      df |>
        dplyr::filter(!is.na(.data$earmarking_name), !is.na(.data$year)) |>
        dplyr::group_by(.data$year, .data$earmarking_name) |>
        dplyr::summarise(
          total_funding = sum(.data$transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::mutate(
          x = factor(.data$year, levels = sort(unique(.data$year)))
        )
    },

    "region" = {
      # Calculate region totals for ordering
      region_totals <- df |>
        dplyr::mutate(
          unhcr_region = dplyr::case_when(
            is.na(.data$unhcr_region) ~ "global/HQ",
            trimws(.data$unhcr_region) == "" ~ "global/HQ",
            TRUE ~ .data$unhcr_region
          )) |>
        dplyr::filter(!is.na(.data$unhcr_region), !is.na(.data$earmarking_name)) |>
        dplyr::group_by(.data$unhcr_region) |>
        dplyr::summarise(
          region_total = sum(.data$transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::arrange(dplyr::desc(region_total))
      
      df |>
        dplyr::mutate(
          unhcr_region = dplyr::case_when(
            is.na(.data$unhcr_region) ~ "global/HQ",
            trimws(.data$unhcr_region) == "" ~ "global/HQ",
            TRUE ~ .data$unhcr_region
          )) |>
        dplyr::filter(!is.na(.data$unhcr_region), !is.na(.data$earmarking_name)) |>
        dplyr::group_by(.data$unhcr_region, .data$earmarking_name) |>
        dplyr::summarise(
          total_funding = sum(.data$transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::mutate(
          x = factor(.data$unhcr_region, levels = rev(region_totals$unhcr_region))
        )
    },

    "country" = {
      # Calculate country totals for ordering
      country_totals <- df |>
        dplyr::filter(!is.na(.data$ctr_name), !is.na(.data$earmarking_name)) |>
        dplyr::group_by(.data$ctr_name) |>
        dplyr::summarise(
          country_total = sum(.data$transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::arrange(dplyr::desc(country_total))
      
      df |>
        dplyr::filter(!is.na(.data$ctr_name), !is.na(.data$earmarking_name)) |>
        dplyr::group_by(.data$ctr_name, .data$earmarking_name) |>
        dplyr::summarise(
          total_funding = sum(.data$transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::mutate(
          x = factor(.data$ctr_name, levels = rev(country_totals$ctr_name))
        )
    },

    "sector" = {
      # Calculate sector totals for ordering
      sector_totals <- df |>
        dplyr::left_join(iati::dataSector, by = "iati_identifier") |>
        dplyr::filter(!is.na(.data$sector_desc), !is.na(.data$earmarking_name)) |>
        dplyr::group_by(.data$sector_desc) |>
        dplyr::summarise(
          sector_total = sum(.data$transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::arrange(dplyr::desc(sector_total))
      
      df |>
        dplyr::left_join(iati::dataSector, by = "iati_identifier") |>
        dplyr::filter(!is.na(.data$sector_desc), !is.na(.data$earmarking_name)) |>
        dplyr::group_by(.data$sector_desc, .data$earmarking_name) |>
        dplyr::summarise(
          total_funding = sum(.data$transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::mutate(
          x = factor(.data$sector_desc, levels = rev(sector_totals$sector_desc))
        )
    }
  )

  # Create title with total funding amount and date information
  if (!is.null(year_filter) && length(year_filter) == 1) {
    title <- paste("Earmarking for", donor_name, "in", year_filter, "| Total:", formatted_total, "USD")
  } else if (!is.null(year_filter) && length(year_filter) > 1) {
    years_range <- paste(min(year_filter), "-", max(year_filter))
    title <- paste("Earmarking for", donor_name, years_range, "| Total:", formatted_total, "USD")
  } else {
    title <- paste("Earmarking for", donor_name, "| Total:", formatted_total, "USD")
  }

  # Define manual color scale for earmarking
  earmarking_colors <- c(
    "Tightly Earmarked" = "#C00000",
    "Earmarked" = "#FFC000",
    "Softly Earmarked" = "#0090BC",
    "Unearmarked" = "#36B3A1"
  )

  # Plot - special handling for global (regular bar chart with flipped coordinates)
  if (by == "global") {
    # For global, we want a regular bar chart (not stacked) with flip
    # Order bars so highest values are at top when flipped
    show_data <- show_data |>
      dplyr::mutate(
        earmarking_name = factor(.data$earmarking_name, 
                                 levels = rev(unique(.data$earmarking_name)))
      )
    
    p <- ggplot2::ggplot(
      show_data,
      ggplot2::aes(x = earmarking_name, y = total_funding, fill = earmarking_name)
    ) +
      ggplot2::geom_col() +
      unhcrthemes::theme_unhcr(grid = "X", axis = "Y", axis_title = "Y") +
      ggplot2::scale_y_continuous(
        labels = scales::label_number(scale_cut = scales::cut_short_scale())
      ) +
      ggplot2::scale_fill_manual(values = earmarking_colors) +
      ggplot2::coord_flip() +  # Always flip for global view
      ggplot2::labs(
        title = title,
        subtitle = "Global overview (ordered by total descending)",
        x = "Earmarking Type",
        y = "Total Funding (USD)",
        caption = "Source: Data published by UNHCR as part of the International Aid Transparency Initiative (IATI)"
      ) +
      ggplot2::theme(legend.position = "none")  # Hide legend for global view
    
  } else {
    # For other groupings, use stacked bar chart
    # Ensure earmarking_name is a factor with consistent levels
    show_data <- show_data |>
      dplyr::mutate(
        earmarking_name = factor(.data$earmarking_name,
                                 levels = names(earmarking_colors))
      )
    
    # Create subtitle based on grouping type
    subtitle <- if (by == "date") {
      paste("Grouped by", by, "(ordered chronologically)")
    } else {
      paste("Grouped by", by, "(ordered by total descending)")
    }
    
    p <- ggplot2::ggplot(
      show_data,
      ggplot2::aes(x = x, y = total_funding, fill = earmarking_name)
    ) +
      ggplot2::geom_col(position = "stack") +
      unhcrthemes::theme_unhcr(grid = "X", axis = "Y", axis_title = "Y") +
      ggplot2::scale_y_continuous(
        labels = scales::label_number(scale_cut = scales::cut_short_scale())
      ) +
      ggplot2::scale_fill_manual(
        values = earmarking_colors,
        name = "Earmarking Type"
      ) +
      ggplot2::labs(
        title = title,
        subtitle = subtitle,
        x = NULL,
        y = "Total Funding (USD)",
        caption = "Source: Data published by UNHCR as part of the International Aid Transparency Initiative (IATI)"
      )
    
    # Flip for readability when there are many categories on x (not for date/global)
    if (by %in% c("region", "country", "sector")) {
      p <- p + ggplot2::coord_flip()
    }
  }

  p
}
```

```{r example-show_donor_earmarking, message=FALSE, warning=FALSE, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center",  out.width = "90%"}
show_donor_earmarking(donor_name = "Private donors",
                                         year = c(2022, 2023, 2024, 2025),
                                         by = "global") 
show_donor_earmarking(donor_name = "Private donors",
                                         year = c(2022, 2023, 2024, 2025),
                                         by = "date") 
show_donor_earmarking(donor_name = "Private donors",
                                         year = c(  2025),
                                         by = "region") 
```
  
```{r tests-show_donor_earmarking}
test_that("show_donor_earmarking works", {
  expect_true(inherits(show_donor_earmarking, "function")) 
})
```

## show_donor_earmarking_flexibility_over_time

```{r function-show_donor_earmarking_flexibility_over_time}
#' Plot donor earmarking flexibility over time
#'
#' @description This function creates a stacked bar chart showing the proportion
#' of each earmarking category for a specific donor over several years.
#'
#' @param donor_name The name of the donor to plot.
#' @param programme_lab A character vector corresponding to the name of the programme.
#' @param iati_identifier_ops A character vector corresponding to the name of the operation.
#' @param ctr_name A character vector corresponding to the name of the country.
#'
#' @import ggplot2
#' @import dplyr
#' @import scales
#' @import unhcrthemes
#'
#' @export
show_donor_earmarking_flexibility_over_time <- function(donor_name,
                                                        programme_lab = NULL,
                                                        iati_identifier_ops = NULL,
                                                        ctr_name = NULL) {

  # Basic data preparation
  df <- iati::dataTransaction |>
    dplyr::left_join(iati::dataActivity, by = "iati_identifier") |>
    dplyr::filter(transaction_provider_org == donor_name,
                  transaction_type_name == "Incoming Commitment")

  # Filtering
  if (!is.null(programme_lab)) {
    df <- df |> dplyr::filter(programmme_lab == {{programme_lab}})
  } else if (!is.null(iati_identifier_ops)) {
    df <- df |> dplyr::filter(iati_identifier_ops == {{iati_identifier_ops}})
  } else if (!is.null(ctr_name)) {
    df <- df |> dplyr::filter(ctr_name == {{ctr_name}})
  }

  # Summarization
  earmarking_over_time <- df |>
    dplyr::group_by(year, earmarking_name) |>
    dplyr::summarise(total_funding = sum(transaction_value_USD, na.rm = TRUE)) |>
    dplyr::filter(!is.na(earmarking_name))

  # Plotting
  p <- ggplot2::ggplot(earmarking_over_time, ggplot2::aes(x = year, y = total_funding, fill = earmarking_name)) +
    ggplot2::geom_bar(stat = "identity", position = "fill") +
    ggplot2::scale_y_continuous(labels = scales::percent_format()) +
    unhcrthemes::theme_unhcr(grid = "Y", axis = "X", axis_title = "X", font_size = 16) +
    ggplot2::labs(
      title = paste("Earmarking Flexibility Over Time for", donor_name, " in ",ctr_name ),
      subtitle = "Proportion of funding by earmarking category",
      x = "Year",
      y = "Proportion of Total Funding",
      fill = "Earmarking Type",
      caption = "Source: Data published by UNHCR as part of the International Aid Transparency Initiative (IATI)"
    )

  p
}
```

```{r example-show_donor_earmarking_flexibility_over_time, message=FALSE, warning=FALSE, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center",  out.width = "90%"}
# Earmarking Flexibility Over Time
show_donor_earmarking_flexibility_over_time(donor_name = "Private donors",
                                            ctr_name = "Syria")


```
  
```{r tests-show_donor_earmarking_flexibility_over_time}
test_that("show_donor_earmarking_flexibility_over_time works", {
  expect_true(inherits(show_donor_earmarking_flexibility_over_time, "function")) 
})
```

## show_donor_transaction_desc

```{r function-show_donor_transaction_desc}
#' Plot donor transaction description
#'
#' @description
#' Creates a visualization showing the breakdown of a donor's funding by transaction description.
#' If only `by` is NULL, it returns a bar chart of transaction descriptions.
#' If `by` is provided, it returns a heatmap cross-tabulation of transaction description vs the specified dimension.
#'
#' @param donor_name Character. The name of the donor to plot.
#' @param by Optional character. A second category to create a heatmap with transaction description.
#'   One of "unhcr_region", "year", "earmarking_name", or "ctr_name".
#' @param year Optional numeric/integer vector. Year(s) to filter on.
#' @param programme_lab Optional character vector. Filter for programme name.
#' @param iati_identifier_ops Optional character vector. Filter for operation ID.
#' @param ctr_name Optional character vector. Filter for country name.
#' @param top_n Integer. The number of top transaction descriptions to show.
#'
#' @return A ggplot object.
#'
#' @import ggplot2
#' @import dplyr
#' @import scales
#' @import forcats
#' @import stringr
#' @import unhcrthemes
#'
#' @export
show_donor_transaction_desc <- function(donor_name,
                                        by = NULL,
                                        year = NULL,
                                        programme_lab = NULL,
                                        iati_identifier_ops = NULL,
                                        ctr_name = NULL,
                                        top_n = 10) {

  # ---- 0) Validate inputs ----
  allowed_by <- c("unhcr_region", "year", "earmarking_name", "ctr_name")
  
  if (!is.null(by)) {
    if (!by %in% allowed_by) {
      stop("`by` must be one of: ", paste(allowed_by, collapse = ", "))
    }
  }
  
  if (!is.numeric(top_n) || length(top_n) != 1 || top_n < 1) {
    stop("`top_n` must be a single integer >= 1.")
  }

  # Avoid name collisions with columns (year arg vs year column, etc.)
  year_filter      <- year
  programme_filter <- programme_lab
  ops_filter       <- iati_identifier_ops
  country_filter   <- ctr_name

  # ---- 1) Load & filter data ----
  df <- iati::dataTransaction |>
    dplyr::left_join(iati::dataActivity, by = "iati_identifier") |>
    dplyr::filter(
      .data$transaction_provider_org == donor_name,
      .data$transaction_type_name == "Incoming Commitment"
    )

  if (!is.null(year_filter)) {
    df <- df |> dplyr::filter(.data$year %in% .env$year_filter)
  }
  if (!is.null(programme_filter)) {
    df <- df |> dplyr::filter(.data$programme_lab %in% .env$programme_filter)
  }
  if (!is.null(ops_filter)) {
    df <- df |> dplyr::filter(.data$iati_identifier_ops %in% .env$ops_filter)
  }
  if (!is.null(country_filter)) {
    df <- df |> dplyr::filter(.data$ctr_name %in% .env$country_filter)
  }

  # ---- 2) Clean unhcr_region data ----
  # Replace empty or NA unhcr_region with "global/HQ"
  if (!is.null(by) && by == "unhcr_region") {
    df <- df |>
      dplyr::mutate(
        unhcr_region = dplyr::case_when(
          is.na(.data$unhcr_region) ~ "global/HQ",
          trimws(.data$unhcr_region) == "" ~ "global/HQ",
          TRUE ~ .data$unhcr_region
        )
      )
  }

  # ---- 3) Determine grouping columns ----
  # Always include transaction_description, and add 'by' if provided
  col_vars <- c("transaction_description", by)
  col_vars <- col_vars[!is.null(col_vars)]

  # ---- 4) Aggregate (base) ----
  show_data <- df |>
    dplyr::filter(dplyr::if_all(dplyr::all_of(col_vars), ~ !is.na(.))) |>
    dplyr::group_by(dplyr::across(dplyr::all_of(col_vars))) |>
    dplyr::summarise(
      total_funding = sum(.data$transaction_value_USD, na.rm = TRUE),
      .groups = "drop"
    )

  # ---- 5) Lumping helper (Top N + Other) ----
  lump_transaction_desc <- function(data, n) {
    data |>
      dplyr::mutate(
        transaction_description = forcats::fct_lump_n(
          forcats::fct_reorder(
            as.factor(.data$transaction_description),
            total_funding,
            .fun = sum,
            .desc = TRUE
          ),
          n = n,
          w = total_funding,
          other_level = "Other"
        )
      )
  }
  
  # For "by" dimension handling
  process_by_dimension <- function(data, by_var) {
    if (is.null(by_var)) return(data)
    
    if (by_var == "earmarking_name") {
      # Preserve all 4 earmarking categories
      data <- data |>
        dplyr::mutate(
          earmarking_name = factor(.data$earmarking_name,
            levels = c("Tightly Earmarked", "Earmarked", "Softly Earmarked", "Unearmarked")
          )
        )
    } else if (by_var == "year") {
      # Order years chronologically
      data <- data |>
        dplyr::mutate(
          year = factor(.data$year, levels = sort(unique(.data$year)))
        )
    } else if (by_var %in% c("unhcr_region", "ctr_name")) {
      # For region and country, show top categories based on data
      # These will be ordered by total in the heatmap
      data <- data
    }
    
    return(data)
  }

  # Apply lumping to transaction description (always)
  show_data <- lump_transaction_desc(show_data, top_n)
  
  # Process the 'by' dimension if provided
  show_data <- process_by_dimension(show_data, by)
  
  # Re-aggregate after lumping/processing
  show_data <- show_data |>
    dplyr::group_by(dplyr::across(dplyr::all_of(col_vars))) |>
    dplyr::summarise(total_funding = sum(.data$total_funding, na.rm = TRUE), .groups = "drop")

  # ---- 6) Calculate total funding for title ----
  total_funding_amount <- sum(show_data$total_funding, na.rm = TRUE)
  formatted_total <- scales::label_number(
    scale_cut = scales::cut_short_scale(),
    accuracy = 0.1
  )(total_funding_amount)

  # ---- 7) Create title ----
  if (!is.null(year_filter) && length(year_filter) == 1) {
    title <- paste("Transaction Description for", donor_name, "in", year_filter, "| Total:", formatted_total, "USD")
  } else if (!is.null(year_filter) && length(year_filter) > 1) {
    years_range <- paste(min(year_filter), "-", max(year_filter))
    title <- paste("Transaction Description for", donor_name, years_range, "| Total:", formatted_total, "USD")
  } else {
    title <- paste("Transaction Description for", donor_name, "| Total:", formatted_total, "USD")
  }

  # ---- 8) Create subtitle ----
  subtitle_text <- if (is.null(by)) {
    if (!is.null(country_filter)) {
      paste0("In ", paste(country_filter, collapse = ", "))
    } else if (!is.null(programme_filter)) {
      paste0("For programme(s): ", paste(programme_filter, collapse = ", "))
    } else {
      paste0("Top ", top_n, " transaction descriptions")
    }
  } else {
    paste("Transaction description by", stringr::str_to_title(gsub("_", " ", by)))
  }

  # ---- 9) Plotting ----
  if (is.null(by)) {
    # BAR CHART - Transaction descriptions only
    
    # Prepare data for bar chart (summarize and order)
    bar_data <- show_data |>
      dplyr::group_by(.data$transaction_description) |>
      dplyr::summarise(total_funding = sum(.data$total_funding, na.rm = TRUE), .groups = "drop") |>
      dplyr::mutate(
        transaction_description = forcats::fct_reorder(.data$transaction_description, .data$total_funding, .desc = FALSE)
      )
    
    p <- ggplot2::ggplot(
      bar_data,
      ggplot2::aes(x = .data$transaction_description, y = .data$total_funding)
    ) +
      ggplot2::geom_col(fill = "#0072BC") +
      ggplot2::coord_flip() +
      ggplot2::scale_y_continuous(
        labels = scales::label_number(scale_cut = scales::cut_short_scale())
      ) +
      unhcrthemes::theme_unhcr(grid = "X", axis = "y", axis_title = "X", font_size = 18) +
      ggplot2::labs(
        title = title,
        subtitle = subtitle_text,
        x = "Transaction Description",
        y = "Total Funding (USD)",
        caption = "Source: Data published by UNHCR as part of the International Aid Transparency Initiative (IATI)"
      )

  } else {
    # HEATMAP - Transaction description by another dimension
    
    # Determine axis labels
    x_label <- if (by == "ctr_name") "Country" else stringr::str_to_title(gsub("_", " ", by))
    y_label <- "Transaction Description"
    
    # Order transaction descriptions by total funding (highest at top)
    heatmap_data <- show_data |>
      dplyr::group_by(.data$transaction_description) |>
      dplyr::mutate(desc_total = sum(.data$total_funding)) |>
      dplyr::ungroup() |>
      dplyr::mutate(
        transaction_description = forcats::fct_reorder(.data$transaction_description, .data$desc_total, .desc = TRUE)
      )
    
    # For year dimension, ensure proper ordering on x-axis
    if (by == "year") {
      heatmap_data <- heatmap_data |>
        dplyr::mutate(
          !!rlang::sym(by) := factor(!!rlang::sym(by), levels = sort(unique(!!rlang::sym(by))))
        )
    }
    
    p <- ggplot2::ggplot(
      heatmap_data,
      ggplot2::aes(
        x = !!rlang::sym(by),
        y = .data$transaction_description,
        fill = .data$total_funding
      )
    ) +
      ggplot2::geom_tile(color = "white", linewidth = 0.5) +
      ggplot2::scale_fill_gradient(
        low = "#DCEEF9",
        high = "#0072BC",
        labels = scales::label_number(scale_cut = scales::cut_short_scale())
      ) +
      unhcrthemes::theme_unhcr(grid = FALSE, axis = "xy", font_size = 18) +
      ggplot2::theme(
        axis.text.x = ggplot2::element_text(angle = 45, vjust = 1, hjust = 1)
      ) +
      ggplot2::labs(
        title = title,
        subtitle = subtitle_text,
        x = x_label,
        y = y_label,
        fill = "Funding (USD)",
        caption = "Source: Data published by UNHCR as part of the International Aid Transparency Initiative (IATI)"
      )
  }

  p
}
```

```{r example-show_donor_transaction_desc, message=FALSE, warning=FALSE, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center",  out.width = "90%"}

# Show top 10 transaction descriptions for a donor
show_donor_transaction_desc(
  donor_name = "Private donors", 
  year = 2024,
  top_n = 10
)

# Show top 10 transaction descriptions for a donor
show_donor_transaction_desc(
  donor_name = "Private donors", 
  year = 2022:2025,
  top_n = 10
)

# Show earmarking breakdown with proper color coding
show_donor_transaction_desc(
  donor_name = "Private donors",
  by = "earmarking_name",
  year = 2024,
  top_n = 4  # Shows all 4 earmarking types
)

# Show funding by region
show_donor_transaction_desc(
  donor_name = "Private donors",
  by = "unhcr_region",
  year = 2025,
  top_n = 8
)


```
  
```{r tests-show_donor_transaction_desc}
test_that("show_donor_transaction_desc works", {
  expect_true(inherits(show_donor_transaction_desc, "function")) 
})
```

## compare_donor_profiles

```{r function-compare_donor_profiles}
#' Compare donor profiles
#'
#' @description
#' Creates an overlaid bar chart to compare funding profiles of donors based on
#' a selected dimension (earmarking, region, or country).
#'
#' If only ONE donor is provided in `donor_names`, the function automatically adds a
#' comparison profile based on other donors. The method is controlled by `avg_method`:
#' - "mean_of_donors": average of donor-level shares (each donor equal weight)
#' - "pooled": pooled totals across donors (large donors have more weight)
#'
#' @param donor_names Character vector of donor names to compare (length 1 or more).
#' @param by One of "earmarking", "region", or "country".
#' @param avg_method If only one donor is supplied, how to compute the "others" comparator.
#'   One of "mean_of_donors" or "pooled".
#' @param display_mode One of "absolute" (USD values) or "relative" (percentage shares).
#' @param year Optional numeric/integer vector. Year(s) to filter on.
#' @param unhcr_region Optional character vector. Filter for UNHCR region(s).
#' @param programme_lab Optional character vector. Filter for programme name.
#' @param iati_identifier_ops Optional character vector. Filter for operation ID.
#' @param ctr_name Optional character vector. Filter for country name.
#' @param top_n Integer. The number of top categories to show when `by = "country"`.
#'
#' @import ggplot2
#' @import dplyr
#' @import scales
#' @import unhcrthemes
#'
#' @export
compare_donor_profiles <- function(donor_names,
                                   by = c("earmarking", "region", "country"),
                                   avg_method = c("mean_of_donors", "pooled"),
                                   display_mode = c("absolute", "relative"),
                                   year = NULL,
                                   unhcr_region = NULL,
                                   programme_lab = NULL,
                                   iati_identifier_ops = NULL,
                                   ctr_name = NULL,
                                   top_n = NULL) {

  by <- match.arg(by)
  avg_method <- match.arg(avg_method)
  display_mode <- match.arg(display_mode)

  # Avoid collisions with column names
  year_filter      <- year
  region_filter    <- unhcr_region
  programme_filter <- programme_lab
  ops_filter       <- iati_identifier_ops
  country_filter   <- ctr_name

  donor_names <- unique(donor_names)
  add_comparator <- length(donor_names) == 1

  # ---- 1) Load base data (ALL donors), then apply filters ----
  df_base <- iati::dataTransaction |>
    dplyr::left_join(iati::dataActivity, by = "iati_identifier") |>
    dplyr::filter(.data$transaction_type_name == "Incoming Commitment")

  if (!is.null(year_filter)) {
    df_base <- df_base |> dplyr::filter(.data$year %in% .env$year_filter)
  }
  if (!is.null(region_filter)) {
    df_base <- df_base |> dplyr::filter(.data$unhcr_region %in% .env$region_filter)
  }
  if (!is.null(programme_filter)) {
    df_base <- df_base |> dplyr::filter(.data$programme_lab %in% .env$programme_filter)
  }
  if (!is.null(ops_filter)) {
    df_base <- df_base |> dplyr::filter(.data$iati_identifier_ops %in% .env$ops_filter)
  }
  if (!is.null(country_filter)) {
    df_base <- df_base |> dplyr::filter(.data$ctr_name %in% .env$country_filter)
  }

  # Clean unhcr_region: replace NA/empty with "Global/HQ"
  df_base <- df_base |>
    dplyr::mutate(
      unhcr_region = dplyr::case_when(
        is.na(.data$unhcr_region) ~ "Global/HQ",
        trimws(.data$unhcr_region) == "" ~ "Global/HQ",
        TRUE ~ .data$unhcr_region
      )
    )

  # ---- 2) Helper: build (donor, dimension, total_funding) ----
  build_profile <- function(df_in, by) {
    if (by == "earmarking") {
      df_in |>
        dplyr::filter(!is.na(.data$earmarking_name)) |>
        dplyr::group_by(.data$transaction_provider_org, .data$earmarking_name) |>
        dplyr::summarise(
          total_funding = sum(.data$transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::rename(dimension = .data$earmarking_name)
    } else if (by == "region") {
      df_in |>
        dplyr::group_by(.data$transaction_provider_org, .data$unhcr_region) |>
        dplyr::summarise(
          total_funding = sum(.data$transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::rename(dimension = .data$unhcr_region)
    } else { # by == "country"
      df_in |>
        dplyr::filter(!is.na(.data$ctr_name)) |>
        dplyr::group_by(.data$transaction_provider_org, .data$ctr_name) |>
        dplyr::summarise(
          total_funding = sum(.data$transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::rename(dimension = .data$ctr_name)
    }
  }

  # ---- 3) Selected donors ----
  selected_df <- df_base |>
    dplyr::filter(.data$transaction_provider_org %in% .env$donor_names)

  show_selected <- build_profile(selected_df, by)

  if (nrow(show_selected) == 0) {
    stop("No data found for the selected donor(s) under the specified filters.")
  }

  # ---- 4) Auto comparator if only one donor provided ----
  comparator_label <- NULL

  if (add_comparator) {
    focal <- donor_names[[1]]

    others_df <- df_base |>
      dplyr::filter(.data$transaction_provider_org != .env$focal)

    show_others <- build_profile(others_df, by)

    if (nrow(show_others) == 0) {
      warning("No data found for 'other donors' under the specified filters. Returning only the selected donor.")
      show_data <- show_selected
      add_comparator <- FALSE
      
    } else {

      if (avg_method == "mean_of_donors") {
        comparator_label <- "Average of other donors"

        # per-donor totals for others
        others_totals <- show_others |>
          dplyr::group_by(.data$transaction_provider_org) |>
          dplyr::summarise(donor_total = sum(.data$total_funding, na.rm = TRUE), .groups = "drop")

        # donor-level shares, then mean share across donors (equal weight)
        others_shares <- show_others |>
          dplyr::left_join(others_totals, by = "transaction_provider_org") |>
          dplyr::mutate(share = dplyr::if_else(.data$donor_total > 0,
                                              .data$total_funding / .data$donor_total,
                                              NA_real_)) |>
          dplyr::group_by(.data$dimension) |>
          dplyr::summarise(avg_share = mean(.data$share, na.rm = TRUE), .groups = "drop")

        # For overlaid chart, we need to compute total funding for the comparator
        mean_total_others <- others_totals |>
          dplyr::summarise(mean_total = mean(.data$donor_total, na.rm = TRUE), .groups = "drop") |>
          dplyr::pull(.data$mean_total)

        show_cmp <- others_shares |>
          dplyr::transmute(
            transaction_provider_org = comparator_label,
            dimension = .data$dimension,
            total_funding = .data$avg_share * mean_total_others,
            share = .data$avg_share
          )

      } else if (avg_method == "pooled") {
        comparator_label <- "Other donors (pooled)"

        show_cmp <- show_others |>
          dplyr::group_by(.data$dimension) |>
          dplyr::summarise(
            total_funding = sum(.data$total_funding, na.rm = TRUE),
            .groups = "drop"
          ) |>
          dplyr::mutate(
            transaction_provider_org = comparator_label,
            # Calculate share for relative display
            share = .data$total_funding / sum(.data$total_funding, na.rm = TRUE)
          ) |>
          dplyr::select(.data$transaction_provider_org, .data$dimension, .data$total_funding, .data$share)
      }

      # Calculate shares for selected donor
      selected_total <- sum(show_selected$total_funding, na.rm = TRUE)
      show_selected <- show_selected |>
        dplyr::mutate(
          share = .data$total_funding / selected_total
        )
      
      show_data <- dplyr::bind_rows(show_selected, show_cmp)
    }

  } else {
    # Calculate shares for multiple donors
    if (display_mode == "relative") {
      donor_totals <- show_selected |>
        dplyr::group_by(.data$transaction_provider_org) |>
        dplyr::summarise(donor_total = sum(.data$total_funding, na.rm = TRUE), .groups = "drop")
      
      show_data <- show_selected |>
        dplyr::left_join(donor_totals, by = "transaction_provider_org") |>
        dplyr::mutate(
          share = .data$total_funding / .data$donor_total
        ) |>
        dplyr::select(-.data$donor_total)
    } else {
      show_data <- show_selected |>
        dplyr::mutate(share = NA_real_)
    }
  }

  # ---- 5) Apply top_n filter for country dimension ----
  if (by == "country" && !is.null(top_n) && is.numeric(top_n)) {
    # Keep top_n countries based on total funding across all shown donors
    top_countries <- show_data |>
      dplyr::group_by(.data$dimension) |>
      dplyr::summarise(total = sum(.data$total_funding, na.rm = TRUE), .groups = "drop") |>
      dplyr::arrange(dplyr::desc(.data$total)) |>
      dplyr::slice(1:top_n) |>
      dplyr::pull(.data$dimension)
    
    show_data <- show_data |>
      dplyr::filter(.data$dimension %in% top_countries)
  }

  # ---- 6) Prepare data for overlaid bar chart ----
  # Create factor levels for dimension ordered by total funding
  dimension_levels <- show_data |>
    dplyr::group_by(.data$dimension) |>
    dplyr::summarise(total = sum(.data$total_funding, na.rm = TRUE), .groups = "drop") |>
    dplyr::arrange(dplyr::desc(.data$total)) |>
    dplyr::pull(.data$dimension)
  
  # Add type column for plotting
  show_data <- show_data |>
    dplyr::mutate(
      dimension = factor(.data$dimension, levels = dimension_levels),
      type = dplyr::case_when(
        .data$transaction_provider_org %in% donor_names & add_comparator ~ "Selected Donor",
        .data$transaction_provider_org %in% donor_names & !add_comparator ~ paste(donor_names, collapse = " & "),
        .data$transaction_provider_org == comparator_label ~ "Comparator",
        TRUE ~ "Other"
      ),
      # Select value based on display mode
      value = if (display_mode == "absolute") .data$total_funding else .data$share
    )

  # ---- 7) Define colors and aesthetics ----
  # Use earmarking colors if by = "earmarking"
  if (by == "earmarking") {
    earmarking_colors <- c(
      "Tightly Earmarked" = "#C00000",
      "Earmarked" = "#FFC000",
      "Softly Earmarked" = "#0090BC",
      "Unearmarked" = "#36B3A1"
    )
    
    # Ensure colors match the dimension levels
    fill_colors <- earmarking_colors[dimension_levels[dimension_levels %in% names(earmarking_colors)]]
  } else {
    # For region and country, use a color palette
    fill_colors <- unhcrthemes::unhcr_pal(n = length(dimension_levels), "pal_unhcr")
    names(fill_colors) <- dimension_levels
  }

  # ---- 8) Create title ----
  # Build year string for title
  year_str <- if (!is.null(year_filter)) {
    if (length(year_filter) == 1) {
      paste("in", year_filter)
    } else {
      paste("(", paste(range(year_filter), collapse = "-"), ")")
    }
  } else {
    ""
  }
  
  # Build title based on number of donors
  if (add_comparator) {
    title <- paste(donor_names[1], "vs Comparator:", stringr::str_to_title(by), "Profile", year_str)
  } else if (length(donor_names) == 1) {
    title <- paste(donor_names[1], ":", stringr::str_to_title(by), "Profile", year_str)
  } else {
    title <- paste(paste(donor_names, collapse = " & "), ":", stringr::str_to_title(by), "Comparison", year_str)
  }
  
  # Trim any extra spaces
  title <- stringr::str_squish(title)

  # ---- 9) Build interpretation hints for caption ----
  caption_parts <- c(
    "Source: Data published by UNHCR as part of the International Aid Transparency Initiative (IATI)"
  )
  
  # Add interpretation hints based on chart type
  if (add_comparator) {
    caption_parts <- c(caption_parts, 
                       "Wider transparent bars: Comparator | Narrower solid bars: Selected donor")
    
    # Add method hint
    method_desc <- if (avg_method == "mean_of_donors") {
      "Comparator: equal-weight average of donor-level shares"
    } else {
      "Comparator: pooled totals across all other donors"
    }
    caption_parts <- c(caption_parts, method_desc)
  }
  
  if (by == "earmarking") {
    caption_parts <- c(caption_parts, 
                       "Colors: Red=Tightly Earmarked, Orange=Earmarked, Blue=Softly Earmarked, Green=Unearmarked")
  }
  
  if (display_mode == "relative") {
    caption_parts <- c(caption_parts, "Values show percentage share of total funding")
  } else {
    caption_parts <- c(caption_parts, "Values show absolute USD amounts")
  }
  
  # Add filter information if any filters applied
  filter_parts <- c()
  if (!is.null(region_filter)) {
    filter_parts <- c(filter_parts, paste("Region:", paste(region_filter, collapse = ", ")))
  }
  if (!is.null(country_filter)) {
    filter_parts <- c(filter_parts, paste("Country:", paste(country_filter, collapse = ", ")))
  }
  if (!is.null(programme_filter)) {
    filter_parts <- c(filter_parts, paste("Programme:", paste(programme_filter, collapse = ", ")))
  }
  
  if (length(filter_parts) > 0) {
    caption_parts <- c(caption_parts, paste("Filters:", paste(filter_parts, collapse = "; ")))
  }
  
  caption <- paste(caption_parts, collapse = " | ")

  # ---- 10) Plot: Fully overlaid bar chart ----
  # Separate data for plotting
  plot_data <- show_data
  
  # Set bar widths and transparency
  bar_widths <- c("Selected Donor" = 0.6, "Comparator" = 0.8)
  bar_alphas <- c("Selected Donor" = 0.9, "Comparator" = 0.4)
  
  # Get unique types in correct order (Comparator first for layering)
  types_in_data <- unique(plot_data$type)
  # Ensure Comparator is drawn first (behind) if present
  if ("Comparator" %in% types_in_data) {
    plot_order <- c("Comparator", setdiff(types_in_data, "Comparator"))
  } else {
    plot_order <- types_in_data
  }
  
  # Create base plot
  p <- ggplot2::ggplot()
  
  # Add bars in correct order (comparator first, then selected donor)
  for (bar_type in plot_order) {
    type_data <- plot_data |> dplyr::filter(.data$type == bar_type)
    
    if (nrow(type_data) > 0) {
      p <- p + ggplot2::geom_col(
        data = type_data,
        ggplot2::aes(x = .data$dimension, y = .data$value, fill = .data$dimension),
        width = bar_widths[bar_type],
        alpha = bar_alphas[bar_type],
        position = "identity"  # Fully overlaid
      )
    }
  }
  
  # Create custom theme without caption settings from unhcrthemes
  base_theme <- unhcrthemes::theme_unhcr(grid = "X", axis = "y", axis_title = "X", font_size = 18)
  
  # Remove the caption element from base_theme if it exists
  if (!is.null(base_theme$plot.caption)) {
    base_theme$plot.caption <- NULL
  }
  
  # Add plot elements with custom caption
  p <- p +
    ggplot2::coord_flip() +
    ggplot2::scale_fill_manual(values = fill_colors, name = stringr::str_to_title(by)) +
    base_theme +
    ggplot2::labs(
      title = title,
      x = NULL,
      y = if (display_mode == "absolute") "Total Funding (USD)" else "Share of Total Funding (%)",
      caption = caption
    ) +
    ggplot2::theme(
      legend.position = "right",
      legend.key.size = ggplot2::unit(0.8, "cm"),
      plot.caption = ggplot2::element_text(size = 10, hjust = 0, color = "gray40", lineheight = 1.2)
    )
  
  # Add appropriate y-axis scale
  if (display_mode == "absolute") {
    p <- p + ggplot2::scale_y_continuous(
      labels = scales::label_number(scale_cut = scales::cut_short_scale()),
      expand = ggplot2::expansion(mult = c(0, 0.1))
    )
  } else {
    p <- p + ggplot2::scale_y_continuous(
      labels = scales::label_percent(accuracy = 1),
      expand = ggplot2::expansion(mult = c(0, 0.05))
    )
  }

  p
}
```

```{r example-compare_donor_profiles, message=FALSE, warning=FALSE, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center",  out.width = "90%"}
# Compare Donor Profiles

compare_donor_profiles(
  donor_names = "Private donors",
  by = "earmarking",
  year = 2025,
  avg_method = "mean_of_donors",
  display_mode = "absolute"
)


compare_donor_profiles(
  donor_names = "Private donors",
  by = "earmarking",
  year = 2025,
  avg_method = "pooled"
)


compare_donor_profiles(
  donor_names = "Private donors",
  by = "region",
  year = 2025,
  avg_method = "pooled"
)

compare_donor_profiles(
  donor_names = c("Private donors", 
 "Switzerland - Swiss Agency for Development and Cooperation (SDC)"), 
   by = "earmarking", year = 2025, ctr_name = "Brazil")
```
  
```{r tests-compare_donor_profiles}
test_that("show_compare_donor_profiles works", {
  expect_true(inherits(compare_donor_profiles, "function")) 
})
```

## show_donor_geographic_priority_shift

```{r function-show_donor_geographic_priority_shift}
#' Plot donor geographic priority shift over time
#'
#' @param donor_name The name of the specific donor to highlight.
#' @param top_n_countries The number of top recipient countries to display for the donor.
#' @param start_year The starting year for the plot.
#' @param end_year The ending year for the plot.
#' @param verbose Logical, whether to print debug messages.
#'
#' @return A ggplot object.
#' @export
show_donor_geographic_priority_shift <- function(donor_name, 
                                                 top_n_countries = 5, 
                                                 start_year = NULL, 
                                                 end_year = NULL,
                                                 verbose = TRUE) {
  
  data_activity <- iati::dataActivity
  data_transaction <- iati::dataTransaction
  
  
   
  # Prepare data
  df_plot <- data_transaction |>
    inner_join(
      data_activity |> select(iati_identifier, ctr_name), 
      by = "iati_identifier"
    ) |>
    mutate(
      year = lubridate::year(lubridate::ymd(transaction_date)),
      transaction_value = as.numeric(transaction_value)
    ) |>
    filter(!is.na(year), !is.na(transaction_value_USD), !is.na(ctr_name)) |>
    group_by(transaction_provider_org, year, ctr_name) |>
    summarise(total_funding = sum(transaction_value_USD, na.rm = TRUE), .groups = "drop") |>
    ungroup()
  
  # Filter by year if specified
  if (!is.null(start_year)) {
    df_plot <- filter(df_plot, year >= start_year)
  }
  if (!is.null(end_year)) {
    df_plot <- filter(df_plot, year <= end_year)
  }
  
  # Calculate percentage of funding per country per year for the selected donor
  df_donor_geo_pct <- df_plot |>
    filter(transaction_provider_org == donor_name) |>
    group_by(year) |>
    mutate(total_year_funding = sum(total_funding, na.rm = TRUE)) |>
    ungroup() |>
    mutate(
      funding_pct = total_funding / total_year_funding,
      recipient_country = forcats::fct_reorder(ctr_name, total_funding, .fun = sum, .desc = TRUE)
    )
  
  # Identify top N countries for the donor across all selected years
  top_countries_donor <- df_donor_geo_pct |>
    group_by(recipient_country) |>
    summarise(total_funding_country = sum(total_funding, na.rm = TRUE), .groups = "drop") |>
    arrange(desc(total_funding_country)) |>
    head(top_n_countries) |>
    pull(recipient_country)
  
  # Filter for top N countries and group others
  df_show_final <- df_donor_geo_pct |>
    mutate(
      country_group = ifelse(recipient_country %in% top_countries_donor, as.character(recipient_country), "Other Countries")
    ) |>
    group_by(year, country_group) |>
    summarise(funding_pct = sum(funding_pct, na.rm = TRUE), .groups = "drop") |>
    ungroup() |>
    # Ensure "Other Countries" is at the bottom of the stack
    mutate(country_group = factor(country_group, levels = c(rev(top_countries_donor), "Other Countries")))
  
  # Plotting
  p <- ggplot(df_show_final, aes(x = year, y = funding_pct, fill = country_group)) +
    geom_bar(stat = "identity", position = "stack") +
    unhcrthemes::scale_fill_unhcr_d("pal_blue", order = c(1:top_n_countries, top_n_countries + 1)) + # Use UNHCR palette
    labs(
      title = paste0("Geographic Priority Shift for ", donor_name),
      subtitle = paste0("Top ", top_n_countries, " Countries vs. Others (", 
                        min(df_show_final$year), "-", max(df_show_final$year), ")"),
      x = "Year",
      y = "Percentage of Total Funding",
      fill = "Recipient Country"
    ) +
    scale_y_continuous(labels = scales::percent) +
    unhcrthemes::theme_unhcr(grid = "Y", axis = "X", axis_title = FALSE, font_size = 18) +
    theme(legend.position = "right")
  
  return(p)
}

```

```{r example-show_donor_geographic_priority_shift}
# Example usage: 
p_geo <- show_donor_geographic_priority_shift(
   donor_name = "Private donors", 
   top_n_countries = 4,
   start_year = 2022,
   end_year = 2025
 )
print(p_geo)
```

```{r tests-show_donor_geographic_priority_shift}
test_that("show_donor_geographic_priority_shift works", {
  # Test with a specific donor
  p_geo1 <- show_donor_geographic_priority_shift( 
    donor_name = "Private donors", 
    top_n_countries = 4,
   start_year = 2022,
   end_year = 2025
  )
  expect_true(ggplot2::is.ggplot(p_geo1)) 

})
```

## show_donor_geographic_diversification

```{r function-show_donor_geographic_diversification}
#' Plot donor geographic diversification over time
#'
#' @param donor_name The name of the donor to highlight.
#' @param start_year Optional start year filter.
#' @param end_year Optional end year filter.
#' @param other_stat Statistic for "Other donors": one of "mean" or "median".
#' @param verbose Logical, whether to print debug messages.
#'
#' @return A ggplot object.
#' @export
show_donor_geographic_diversification <- function(donor_name,
                                                  start_year = NULL,
                                                  end_year = NULL,
                                                  other_stat = c("mean", "median"),
                                                  verbose = TRUE) {

  other_stat <- match.arg(other_stat)

  data_activity <- iati::dataActivity
  data_transaction <- iati::dataTransaction
  df <-  data_transaction
 

  # ---- 2) Prepare joined dataset + parse year robustly ----
  df <- data_transaction |>
    dplyr::filter(.data$transaction_type_name == "Incoming Commitment") |>  
    dplyr::left_join(data_activity , by = "iati_identifier")  |>
    dplyr::filter(!is.na(.data$year), !is.na(.data$ctr_name))

  # ---- 3) Optional year filtering ----
  if (!is.null(start_year)) df <- df |> dplyr::filter(.data$year >= .env$start_year)
  if (!is.null(end_year))   df <- df |> dplyr::filter(.data$year <= .env$end_year)

  if (nrow(df) == 0) stop("No data after filtering (check start_year/end_year).")

  # ---- 4) Countries per donor-year ----
  df_countries <- df |>
    dplyr::group_by(.data$transaction_provider_org, .data$year) |>
    dplyr::summarise(
      num_countries = dplyr::n_distinct(.data$ctr_name),
      .groups = "drop"
    )

  # ---- 5) Overall average across all donors per year ----
  avg_all <- df_countries |>
    dplyr::group_by(.data$year) |>
    dplyr::summarise(
      average_countries_all = mean(.data$num_countries, na.rm = TRUE),
      .groups = "drop"
    )

  # ---- 6) Selected donor series + "Other donors" statistic ----
  donor_exists <- donor_name %in% df_countries$transaction_provider_org
  if (!donor_exists && verbose) {
    warning("Donor '", donor_name, "' not found in data. Plotting only all-donor average and other-donor statistic.")
  }

  selected_series <- df_countries |>
    dplyr::filter(.data$transaction_provider_org == donor_name) |>
    dplyr::mutate(series = "Selected donor")

  other_label <- paste0("Other donors (", other_stat, ")")

  others_series <- df_countries |>
    dplyr::filter(.data$transaction_provider_org != donor_name) |>
    dplyr::group_by(.data$year) |>
    dplyr::summarise(
      num_countries =
        if (other_stat == "mean") mean(.data$num_countries, na.rm = TRUE)
        else median(.data$num_countries, na.rm = TRUE),
      .groups = "drop"
    ) |>
    dplyr::mutate(series = other_label)

  plot_series <- dplyr::bind_rows(selected_series, others_series) |>
    dplyr::select("year", "num_countries", "series") |>
    dplyr::mutate(
      series = factor(.data$series, levels = c("Selected donor", other_label))
    )

  # ---- 7) Plot ----
  col_selected <- "#0072BC"  # blue
  col_others   <- "#C43C35"  # red

  # ✅ Build named vectors properly (no expressions on LHS of '=')
  color_values <- c(col_selected, col_others)
  names(color_values) <- c("Selected donor", other_label)

  linetype_values <- c("solid", "dotdash")
  names(linetype_values) <- c("Selected donor", other_label)

  # If donor doesn't exist, drop that level from scales & data
  if (!donor_exists) {
    plot_series <- plot_series |> dplyr::filter(.data$series != "Selected donor") |> droplevels()
    color_values <- color_values[names(color_values) != "Selected donor"]
    linetype_values <- linetype_values[names(linetype_values) != "Selected donor"]
  }

  p <- ggplot2::ggplot() +
    ggplot2::geom_line(
      data = plot_series,
      ggplot2::aes(x = .data$year, y = .data$num_countries, color = .data$series, linetype = .data$series),
      linewidth = 1
    ) +
    ggplot2::geom_line(
      data = avg_all,
      ggplot2::aes(x = .data$year, y = .data$average_countries_all),
      color = "black",
      linetype = "dashed",
      linewidth = 0.8,
      alpha = 0.6
    ) +
    ggplot2::scale_color_manual(values = color_values, drop = TRUE) +
    ggplot2::scale_linetype_manual(values = linetype_values, drop = TRUE) +
    ggplot2::labs(
      title = if (donor_exists) paste0("Geographic Diversification for ", donor_name)
              else paste0("Geographic Diversification (donor not found: ", donor_name, ")"),
      subtitle = paste0("Selected donor vs ", other_label, " and overall average (dashed)."),
      y = "Number of recipient countries",
      x = "Year",
      color = NULL,
      linetype = NULL,
      caption = "Source: Data published by UNHCR as part of the International Aid Transparency Initiative (IATI)"
    ) +
    unhcrthemes::theme_unhcr(grid = "Y", axis = "X", axis_title = FALSE, font_size = 18) +
    ggplot2::theme(legend.position = "bottom")

  p
}

```

```{r example-show_donor_geographic_diversification}
# Example usage:
p_geo_div <- show_donor_geographic_diversification( 
  donor_name = "Private donors", 
   start_year = 2022, 
   end_year = 2025,
  other_stat = "mean"
  )
print(p_geo_div)

```

```{r tests-show_donor_geographic_diversification}
test_that("show_donor_geographic_diversification works", {
  # Test with a specific donor and year range
  p_geo_div1 <- show_donor_geographic_diversification(
        donor_name = "Private donors", 
         start_year = 2022, 
         end_year = 2025,
        other_stat = "mean"
  )
  expect_true(ggplot2::is.ggplot(p_geo_div1))
  
})
```

## show_donor_funding_volatility

```{r function-show_donor_funding_volatility}
#' Plot donor funding volatility
#'
#' @description
#' Creates a volatility view of a donor's incoming commitments:
#' - Points: transaction-level USD amounts for the selected donor
#' - Smoothed line: monthly/quarterly mean transaction value (donor)
#' - Comparator: weighted mean transaction value for all other donors,
#'   weighted by each donor's total received amount (under the same filters)
#' - Forecast: simple trend model (lm on log1p period mean) extended forward
#'
#' Title/subtitle highlight average amount per transaction and transactions per year
#' for the donor vs weighted averages for all other donors combined.
#'
#' @param donor_name Character. The donor to plot.
#' @param year Optional integer/numeric vector. Filter years (e.g., 2023 or c(2022,2023)).
#' @param programme_lab Optional character vector. Filter on programme label.
#' @param iati_identifier_ops Optional character vector. Filter on operation identifier.
#' @param ctr_name Optional character vector. Filter on recipient country name (ctr_name).
#' @param time_unit Aggregation unit for trend line: "month" (default) or "quarter".
#' @param smooth_method Smoother for trend line: "loess" (default) or "gam".
#' @param forecast_horizon Integer. Number of periods (months/quarters) to forecast.
#' @param show_forecast_ci Logical. If TRUE, show a confidence ribbon for the forecast.
#' @param verbose Logical. Print small diagnostics.
#'
#' @return A ggplot object.
#' @export
show_donor_funding_volatility <- function(donor_name,
                                          year = NULL,
                                          programme_lab = NULL,
                                          iati_identifier_ops = NULL,
                                          ctr_name = NULL,
                                          time_unit = c("month", "quarter"),
                                          smooth_method = c("loess", "gam"),
                                          forecast_horizon = 6,
                                          show_forecast_ci = TRUE,
                                          verbose = TRUE) {

  time_unit <- match.arg(time_unit)
  smooth_method <- match.arg(smooth_method)

  # ---- 0) Load data ----
  tx  <- iati::dataTransaction
  act <- iati::dataActivity

  # value column (prefer USD)
  value_col <- dplyr::case_when(
    "transaction_value_USD" %in% names(tx) ~ "transaction_value_USD",
    "transaction_value"     %in% names(tx) ~ "transaction_value",
    TRUE ~ NA_character_
  )
  if (is.na(value_col)) stop("No transaction value column found (`transaction_value_USD` or `transaction_value`).")

  req_tx <- c("iati_identifier", "transaction_date", "transaction_provider_org",
              "transaction_type_name", value_col)
  missing_tx <- setdiff(req_tx, names(tx))
  if (length(missing_tx) > 0) {
    stop("Missing required columns in iati::dataTransaction: ", paste(missing_tx, collapse = ", "))
  }
  if (!("iati_identifier" %in% names(act))) stop("Missing `iati_identifier` in iati::dataActivity.")

  # ---- 1) Join + parse dates robustly ----
  df <- tx |>
    dplyr::left_join(act, by = "iati_identifier") |>
    dplyr::filter(.data$transaction_type_name == "Incoming Commitment") |>
    dplyr::mutate(
      tx_date = as.Date(
        lubridate::parse_date_time(
          .data$transaction_date,
          orders = c("ymd", "Ymd", "ymd HMS", "Ymd HMS", "ymd HM", "Ymd HM", "dmy", "mdy"),
          quiet = TRUE,
          tz = "UTC"
        )
      ),
      year_tx  = lubridate::year(.data$tx_date),
      tx_value = as.numeric(.data[[value_col]])
    ) |>
    dplyr::filter(!is.na(.data$tx_date), !is.na(.data$year_tx), !is.na(.data$tx_value))

  # ---- 2) Optional filters (vector-friendly + safe) ----
  year_filter      <- year
  programme_filter <- programme_lab
  ops_filter       <- iati_identifier_ops
  country_filter   <- ctr_name

  if (!is.null(year_filter)) {
    df <- df |> dplyr::filter(.data$year_tx %in% .env$year_filter)
  }
  if (!is.null(programme_filter)) {
    if (!("programme_lab" %in% names(df))) stop("`programme_lab` column not found in joined data.")
    df <- df |> dplyr::filter(.data$programme_lab %in% .env$programme_filter)
  } else if (!is.null(ops_filter)) {
    if (!("iati_identifier_ops" %in% names(df))) stop("`iati_identifier_ops` column not found in joined data.")
    df <- df |> dplyr::filter(.data$iati_identifier_ops %in% .env$ops_filter)
  } else if (!is.null(country_filter)) {
    if (!("ctr_name" %in% names(df))) stop("`ctr_name` column not found in joined data.")
    df <- df |> dplyr::filter(.data$ctr_name %in% .env$country_filter)
  }

  if (nrow(df) == 0) stop("No data available after filtering.")

  # ---- 3) Split donor vs others ----
  donor_df <- df |> dplyr::filter(.data$transaction_provider_org == donor_name)
  if (nrow(donor_df) == 0) stop("Donor '", donor_name, "' not found under current filters.")
  others_df <- df |> dplyr::filter(.data$transaction_provider_org != donor_name)

  # ---- 4) Define time bucket ----
  bucket_unit <- if (time_unit == "month") "month" else "quarter"
  donor_df  <- donor_df  |> dplyr::mutate(period = lubridate::floor_date(.data$tx_date, unit = bucket_unit))
  others_df <- others_df |> dplyr::mutate(period = lubridate::floor_date(.data$tx_date, unit = bucket_unit))

  # ---- 5) Donor period summaries ----
  donor_period <- donor_df |>
    dplyr::group_by(.data$period) |>
    dplyr::summarise(
      donor_total = sum(.data$tx_value, na.rm = TRUE),
      donor_n     = dplyr::n(),
      donor_mean  = donor_total / donor_n,
      .groups = "drop"
    )

  # ---- 6) Weighted "other donors" period mean ----
  others_totals <- others_df |>
    dplyr::group_by(.data$transaction_provider_org) |>
    dplyr::summarise(donor_total_all = sum(.data$tx_value, na.rm = TRUE), .groups = "drop") |>
    dplyr::filter(.data$donor_total_all > 0) |>
    dplyr::mutate(weight = .data$donor_total_all / sum(.data$donor_total_all, na.rm = TRUE))

  others_period_donor <- others_df |>
    dplyr::group_by(.data$transaction_provider_org, .data$period) |>
    dplyr::summarise(
      total = sum(.data$tx_value, na.rm = TRUE),
      n     = dplyr::n(),
      mean  = total / n,
      .groups = "drop"
    ) |>
    dplyr::left_join(
      others_totals |> dplyr::select(transaction_provider_org, weight),
      by = "transaction_provider_org"
    )

  others_period <- others_period_donor |>
    dplyr::group_by(.data$period) |>
    dplyr::summarise(
      others_weighted_mean = sum(.data$mean * .data$weight, na.rm = TRUE),
      .groups = "drop"
    )

  # ---- 7) Forecast donor trend (lm on log1p of donor_mean) ----
  donor_period_model <- donor_period |>
    dplyr::arrange(.data$period) |>
    dplyr::mutate(t = dplyr::row_number())

  forecast_df <- NULL
  if (nrow(donor_period_model) >= 4 && forecast_horizon > 0) {

    fit <- stats::lm(log1p(donor_mean) ~ t, data = donor_period_model)

    last_period <- max(donor_period_model$period)

    # ✅ No %m+%: use seq.Date (robust, base R)
    step_months <- if (time_unit == "month") 1 else 3
    future_periods <- seq.Date(
      from = last_period,
      by   = paste(step_months, "months"),
      length.out = forecast_horizon + 1
    )[-1]

    future_t <- max(donor_period_model$t) + seq_len(forecast_horizon)

    if (show_forecast_ci) {
      pred_ci <- stats::predict(fit, newdata = data.frame(t = future_t), interval = "confidence")
    
      # guard: ensure we can access columns by name
      pred_ci <- as.data.frame(pred_ci)
    
      forecast_df <- dplyr::tibble(
        period = future_periods,
        pred = expm1(pred_ci$fit),
        lwr  = expm1(pred_ci$lwr),
        upr  = expm1(pred_ci$upr)
      )
    } else {
      pred <- stats::predict(fit, newdata = data.frame(t = future_t))
      forecast_df <- dplyr::tibble(
        period = future_periods,
        pred = expm1(as.numeric(pred))
      )
    }

  }

  # ---- 8) KPI text for title/subtitle ----
  donor_avg_txn <- mean(donor_df$tx_value, na.rm = TRUE)
  donor_n_txn   <- nrow(donor_df)
  donor_years   <- length(unique(donor_df$year_tx))
  donor_txn_per_year <- donor_n_txn / max(donor_years, 1)

  others_kpi <- others_df |>
    dplyr::group_by(.data$transaction_provider_org) |>
    dplyr::summarise(
      total = sum(.data$tx_value, na.rm = TRUE),
      n = dplyr::n(),
      avg_txn = total / n,
      years = dplyr::n_distinct(.data$year_tx),
      txn_per_year = n / pmax(years, 1),
      .groups = "drop"
    ) |>
    dplyr::filter(.data$total > 0) |>
    dplyr::mutate(w = .data$total / sum(.data$total, na.rm = TRUE))

  others_weighted_avg_txn <- sum(others_kpi$avg_txn * others_kpi$w, na.rm = TRUE)
  others_weighted_txn_per_year <- sum(others_kpi$txn_per_year * others_kpi$w, na.rm = TRUE)

  fmt_money <- scales::label_number(scale_cut = scales::cut_short_scale(), accuracy = 0.1)
  fmt_num   <- scales::label_number(accuracy = 0.1)

  title <- paste0("Funding volatility — ", donor_name)
  subtitle <- paste0(
    "Donor avg/txn: ", fmt_money(donor_avg_txn), " | txns/yr: ", fmt_num(donor_txn_per_year),
    "  vs  Other donors (weighted) avg/txn: ", fmt_money(others_weighted_avg_txn),
    " | txns/yr: ", fmt_num(others_weighted_txn_per_year),
    if (!is.null(country_filter)) paste0(" | Filter: ", paste(country_filter, collapse = ", ")) else ""
  )

  # ---- 9) Plot ----
  col_donor    <- "#0072BC"
  col_others   <- "#6B6E70"
  col_forecast <- "#F28E2B"

  p <- ggplot2::ggplot() +
    ggplot2::geom_point(
      data = donor_df,
      ggplot2::aes(x = .data$tx_date, y = .data$tx_value),
      color = col_donor,
      alpha = 0.25,
      size = 1.5
    ) +
    ggplot2::geom_line(
      data = donor_period,
      ggplot2::aes(x = .data$period, y = .data$donor_mean),
      color = col_donor,
      linewidth = 1
    ) +
    ggplot2::geom_smooth(
      data = donor_period,
      ggplot2::aes(x = .data$period, y = .data$donor_mean),
      method  = if (smooth_method == "loess") "loess" else "gam",
      formula = if (smooth_method == "loess") y ~ x else y ~ s(x, bs = "cs"),
      se = FALSE,
      color = col_donor,
      linewidth = 1,
      linetype = "solid",
      alpha = 0.15
    ) +
    ggplot2::geom_line(
      data = others_period,
      ggplot2::aes(x = .data$period, y = .data$others_weighted_mean),
      color = col_others,
      linewidth = 1,
      linetype = "dotdash"
    ) +
    { if (!is.null(forecast_df) && show_forecast_ci)
      ggplot2::geom_ribbon(
        data = forecast_df,
        ggplot2::aes(x = .data$period, ymin = .data$lwr, ymax = .data$upr),
        fill = col_forecast,
        alpha = 0.15
      )
    } +
    { if (!is.null(forecast_df))
      ggplot2::geom_line(
        data = forecast_df,
        ggplot2::aes(x = .data$period, y = .data$pred),
        color = col_forecast,
        linewidth = 1,
        linetype = "dashed"
      )
    } +
    ggplot2::scale_y_continuous(labels = scales::label_number(scale_cut = scales::cut_short_scale())) +
    ggplot2::labs(
      title = title,
      subtitle = subtitle,
      x = "Transaction date",
      y = "Transaction value (USD)",
      caption = paste0(
        "Points: donor transactions. Blue: donor period mean (", time_unit,
        "). Grey: weighted other donors mean. Dashed orange: simple trend forecast. \n",
        "Source: Data published by UNHCR as part of the International Aid Transparency Initiative (IATI)"
      )     
    ) +
    unhcrthemes::theme_unhcr(grid = "Y", axis = "X", axis_title = "X", font_size = 18)

  if (verbose) {
    message(
      "Volatility plot prepared for donor: ", donor_name,
      " | periods: ", nrow(donor_period),
      " | forecast: ", ifelse(is.null(forecast_df), "none", paste0(nrow(forecast_df), " periods"))
    )
  }

  p
}

```

```{r example-show_donor_funding_volatility, message=FALSE, warning=FALSE, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center",  out.width = "90%"}
# Donor Funding Volatility

show_donor_funding_volatility(
  donor_name = "Private donors",
  time_unit = "quarter",
  forecast_horizon = 8
)

show_donor_funding_volatility(donor_name = "Private donors", 
                              ctr_name = "Brazil")
```
  
```{r tests-show_donor_funding_volatility}
test_that("show_donor_funding_volatility works", {
  expect_true(inherits(show_donor_funding_volatility, "function")) 
})
```


```{r development-inflate, eval=FALSE}
# Inflate the package

# You're one inflate from paper to box.
# Build your package from this very Rmd using `fusen::inflate()`
# 
# - Verify your `"DESCRIPTION"` file has been updated
# - Verify your function is in `"R/"` directory
# - Verify your test is in `"tests/testthat/"` directory
# - Verify this Rmd appears in `"vignettes/"` directory

# Keep eval=FALSE to avoid infinite loop in case you hit the knit button
# Execute in the console directly
fusen::inflate(flat_file = "dev/dev_donor_focus.Rmd", clean=TRUE, vignette_name = "-- Donor Analysis")
```



