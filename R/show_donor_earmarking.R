# WARNING - Generated by {fusen} from dev/dev_donor_focus.Rmd: do not edit by hand # nolint: line_length_linter.

#' Plot earmarking composition for a donor (stacked bar chart)
#'
#' @description
#' This function plots the earmarking composition of incoming commitments for a donor.
#' Depending on `by`, it shows a single global bar chart, bars by year, or stacked bars by
#' region/country/sector. All bar charts are ordered by total descending amount, except
#' for date grouping which is ordered chronologically.
#'
#' @param donor_name The name of the donor to plot.
#' @param year A numeric value or a vector of numeric values to filter on year.
#' @param by Grouping dimension: one of "global", "date", "region", "country", "sector".
#' @param programme_lab A character vector of programme labels to filter on.
#' @param iati_identifier_ops A character vector of operation identifiers to filter on.
#' @param ctr_name A character vector of country names to filter on.
#'
#' @import ggplot2
#' @import dplyr
#' @import scales
#' @import unhcrthemes
#'
#' @export
#' @examples
#' show_donor_earmarking(donor_name = "Private donors",
#'                                          year = c(2022, 2023, 2024, 2025),
#'                                          by = "global") 
#' show_donor_earmarking(donor_name = "Private donors",
#'                                          year = c(2022, 2023, 2024, 2025),
#'                                          by = "date") 
#' show_donor_earmarking(donor_name = "Private donors",
#'                                          year = c(  2025),
#'                                          by = "region") 
show_donor_earmarking <- function(donor_name,
                                  year = NULL,
                                  by = c("global", "date", "region", "country", "sector"),
                                  programme_lab = NULL,
                                  iati_identifier_ops = NULL,
                                  ctr_name = NULL) {

  by <- match.arg(by)

  # keep filters in separate objects to avoid name collision with column names
  year_filter <- year
  programme_filter <- programme_lab
  ops_filter <- iati_identifier_ops
  country_filter <- ctr_name

  # Basic data preparation
  df <- iati::dataTransaction |>
    dplyr::left_join(iati::dataActivity, by = "iati_identifier") |>
    dplyr::filter(
      transaction_provider_org == donor_name,
      transaction_type_name == "Incoming Commitment"
    )

  # Filtering (vector-friendly + safe evaluation)
  if (!is.null(year_filter)) {
    df <- df |> dplyr::filter(.data$year %in% .env$year_filter)
  }
  if (!is.null(programme_filter)) {
    df <- df |> dplyr::filter(.data$programme_lab %in% .env$programme_filter)
  } else if (!is.null(ops_filter)) {
    df <- df |> dplyr::filter(.data$iati_identifier_ops %in% .env$ops_filter)
  } else if (!is.null(country_filter)) {
    df <- df |> dplyr::filter(.data$ctr_name %in% .env$country_filter)
  }

  # Calculate total funding for the title
  total_funding_amount <- sum(df$transaction_value_USD, na.rm = TRUE)
  
  # Format total funding for display
  formatted_total <- scales::label_number(
    scale_cut = scales::cut_short_scale(),
    accuracy = 0.1
  )(total_funding_amount)
  
  # Build show_data with a single x column, depending on `by`
  show_data <- switch(
    by,

    "global" = {
      df |>
        dplyr::filter(!is.na(.data$earmarking_name)) |>
        dplyr::group_by(.data$earmarking_name) |>
        dplyr::summarise(
          total_funding = sum(.data$transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::arrange(dplyr::desc(total_funding)) |>
        dplyr::mutate(x = "Global")
    },

    "date" = {
      # For date grouping, order by date chronologically
      df |>
        dplyr::filter(!is.na(.data$earmarking_name), !is.na(.data$year)) |>
        dplyr::group_by(.data$year, .data$earmarking_name) |>
        dplyr::summarise(
          total_funding = sum(.data$transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::mutate(
          x = factor(.data$year, levels = sort(unique(.data$year)))
        )
    },

    "region" = {
      # Calculate region totals for ordering
      region_totals <- df |>
        dplyr::mutate(
          unhcr_region = dplyr::case_when(
            is.na(.data$unhcr_region) ~ "global/HQ",
            trimws(.data$unhcr_region) == "" ~ "global/HQ",
            TRUE ~ .data$unhcr_region
          )) |>
        dplyr::filter(!is.na(.data$unhcr_region), !is.na(.data$earmarking_name)) |>
        dplyr::group_by(.data$unhcr_region) |>
        dplyr::summarise(
          region_total = sum(.data$transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::arrange(dplyr::desc(region_total))
      
      df |>
        dplyr::mutate(
          unhcr_region = dplyr::case_when(
            is.na(.data$unhcr_region) ~ "global/HQ",
            trimws(.data$unhcr_region) == "" ~ "global/HQ",
            TRUE ~ .data$unhcr_region
          )) |>
        dplyr::filter(!is.na(.data$unhcr_region), !is.na(.data$earmarking_name)) |>
        dplyr::group_by(.data$unhcr_region, .data$earmarking_name) |>
        dplyr::summarise(
          total_funding = sum(.data$transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::mutate(
          x = factor(.data$unhcr_region, levels = rev(region_totals$unhcr_region))
        )
    },

    "country" = {
      # Calculate country totals for ordering
      country_totals <- df |>
        dplyr::filter(!is.na(.data$ctr_name), !is.na(.data$earmarking_name)) |>
        dplyr::group_by(.data$ctr_name) |>
        dplyr::summarise(
          country_total = sum(.data$transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::arrange(dplyr::desc(country_total))
      
      df |>
        dplyr::filter(!is.na(.data$ctr_name), !is.na(.data$earmarking_name)) |>
        dplyr::group_by(.data$ctr_name, .data$earmarking_name) |>
        dplyr::summarise(
          total_funding = sum(.data$transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::mutate(
          x = factor(.data$ctr_name, levels = rev(country_totals$ctr_name))
        )
    },

    "sector" = {
      # Calculate sector totals for ordering
      sector_totals <- df |>
        dplyr::left_join(iati::dataSector, by = "iati_identifier") |>
        dplyr::filter(!is.na(.data$sector_desc), !is.na(.data$earmarking_name)) |>
        dplyr::group_by(.data$sector_desc) |>
        dplyr::summarise(
          sector_total = sum(.data$transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::arrange(dplyr::desc(sector_total))
      
      df |>
        dplyr::left_join(iati::dataSector, by = "iati_identifier") |>
        dplyr::filter(!is.na(.data$sector_desc), !is.na(.data$earmarking_name)) |>
        dplyr::group_by(.data$sector_desc, .data$earmarking_name) |>
        dplyr::summarise(
          total_funding = sum(.data$transaction_value_USD, na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::mutate(
          x = factor(.data$sector_desc, levels = rev(sector_totals$sector_desc))
        )
    }
  )

  # Create title with total funding amount and date information
  if (!is.null(year_filter) && length(year_filter) == 1) {
    title <- paste("Earmarking for", donor_name, "in", year_filter, "| Total:", formatted_total, "USD")
  } else if (!is.null(year_filter) && length(year_filter) > 1) {
    years_range <- paste(min(year_filter), "-", max(year_filter))
    title <- paste("Earmarking for", donor_name, years_range, "| Total:", formatted_total, "USD")
  } else {
    title <- paste("Earmarking for", donor_name, "| Total:", formatted_total, "USD")
  }

  # Define manual color scale for earmarking
  earmarking_colors <- c(
    "Tightly Earmarked" = "#C00000",
    "Earmarked" = "#FFC000",
    "Softly Earmarked" = "#0090BC",
    "Unearmarked" = "#36B3A1"
  )

  # Plot - special handling for global (regular bar chart with flipped coordinates)
  if (by == "global") {
    # For global, we want a regular bar chart (not stacked) with flip
    # Order bars so highest values are at top when flipped
    show_data <- show_data |>
      dplyr::mutate(
        earmarking_name = factor(.data$earmarking_name, 
                                 levels = rev(unique(.data$earmarking_name)))
      )
    
    p <- ggplot2::ggplot(
      show_data,
      ggplot2::aes(x = earmarking_name, y = total_funding, fill = earmarking_name)
    ) +
      ggplot2::geom_col() +
      unhcrthemes::theme_unhcr(grid = "X", axis = "Y", axis_title = "Y") +
      ggplot2::scale_y_continuous(
        labels = scales::label_number(scale_cut = scales::cut_short_scale())
      ) +
      ggplot2::scale_fill_manual(values = earmarking_colors) +
      ggplot2::coord_flip() +  # Always flip for global view
      ggplot2::labs(
        title = title,
        subtitle = "Global overview (ordered by total descending)",
        x = "Earmarking Type",
        y = "Total Funding (USD)",
        caption = "Source: Data published by UNHCR as part of the International Aid Transparency Initiative (IATI)"
      ) +
      ggplot2::theme(legend.position = "none")  # Hide legend for global view
    
  } else {
    # For other groupings, use stacked bar chart
    # Ensure earmarking_name is a factor with consistent levels
    show_data <- show_data |>
      dplyr::mutate(
        earmarking_name = factor(.data$earmarking_name,
                                 levels = names(earmarking_colors))
      )
    
    # Create subtitle based on grouping type
    subtitle <- if (by == "date") {
      paste("Grouped by", by, "(ordered chronologically)")
    } else {
      paste("Grouped by", by, "(ordered by total descending)")
    }
    
    p <- ggplot2::ggplot(
      show_data,
      ggplot2::aes(x = x, y = total_funding, fill = earmarking_name)
    ) +
      ggplot2::geom_col(position = "stack") +
      unhcrthemes::theme_unhcr(grid = "X", axis = "Y", axis_title = "Y") +
      ggplot2::scale_y_continuous(
        labels = scales::label_number(scale_cut = scales::cut_short_scale())
      ) +
      ggplot2::scale_fill_manual(
        values = earmarking_colors,
        name = "Earmarking Type"
      ) +
      ggplot2::labs(
        title = title,
        subtitle = subtitle,
        x = NULL,
        y = "Total Funding (USD)",
        caption = "Source: Data published by UNHCR as part of the International Aid Transparency Initiative (IATI)"
      )
    
    # Flip for readability when there are many categories on x (not for date/global)
    if (by %in% c("region", "country", "sector")) {
      p <- p + ggplot2::coord_flip()
    }
  }

  p
}
