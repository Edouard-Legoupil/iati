# WARNING - Generated by {fusen} from dev/dev_donor_focus.Rmd: do not edit by hand # nolint: line_length_linter.

#' Plot donor funding volatility
#'
#' @description
#' Creates a volatility view of a donor's incoming commitments:
#' - Points: transaction-level USD amounts for the selected donor
#' - Smoothed line: monthly/quarterly mean transaction value (donor)
#' - Comparator: weighted mean transaction value for other donors,
#'   weighted by each donor's total received amount (under the same filters)
#' - Forecast: simple trend model (lm on log1p period mean) extended forward
#'
#' Title/subtitle highlight average amount per transaction and average number of 
#' transactions per year for the donor vs weighted averages for other donors combined.
#'
#' @param donor_name Character. The donor to plot.
#' @param year Optional integer/numeric vector. Filter years (e.g., 2023 or c(2022,2023)).
#' @param programme_lab Optional character vector. Filter on programme label.
#' @param iati_identifier_ops Optional character vector. Filter on operation identifier.
#' @param ctr_name Optional character vector. Filter on recipient country name (ctr_name).
#' @param top_n_donors Optional integer. If provided, restricts comparator to
#'   the top N donors by total funding amount (USD) across the filtered period.
#'   NULL (default) includes all other donors in the comparator.
#' @param time_unit Aggregation unit for trend line: "month" (default) or "quarter".
#' @param smooth_method Smoother for trend line: "loess" (default) or "gam".
#' @param forecast_horizon Integer. Number of periods (months/quarters) to forecast.
#' @param show_forecast_ci Logical. If TRUE, show a confidence ribbon for the forecast.
#' @param verbose Logical. Print small diagnostics.
#'
#' @return A ggplot object.
#' @export
#' @examples
#' # Donor Funding Volatility
#'
#' show_donor_funding_volatility(
#'   donor_name = "Private donors",
#'   time_unit = "quarter",
#'   forecast_horizon = 8
#' )
#'
#' show_donor_funding_volatility(
#'   donor_name = "Private donors",
#'   year = 2022:2026,
#'   top_n_donors = 10,,
#'   forecast_horizon = 8,
#'   time_unit = "month"
#' )
#'
#' show_donor_funding_volatility(donor_name = "Private donors", 
#'                               ctr_name = "Brazil")
show_donor_funding_volatility <- function(donor_name,
                                          year = NULL,
                                          programme_lab = NULL,
                                          iati_identifier_ops = NULL,
                                          ctr_name = NULL,
                                          top_n_donors = NULL,
                                          time_unit = c("month", "quarter"),
                                          smooth_method = c("loess", "gam"),
                                          forecast_horizon = 6,
                                          show_forecast_ci = TRUE,
                                          verbose = TRUE) {

  time_unit <- match.arg(time_unit)
  smooth_method <- match.arg(smooth_method)

  # ---- 0) Load data ----
  tx  <- iati::dataTransaction
  act <- iati::dataActivity

  # value column (prefer USD)
  value_col <- dplyr::case_when(
    "transaction_value_USD" %in% names(tx) ~ "transaction_value_USD",
    TRUE ~ NA_character_
  )
  if (is.na(value_col)) stop("No transaction value column found (`transaction_value_USD` or `transaction_value`).")

  req_tx <- c("iati_identifier", "transaction_date", "transaction_provider_org",
              "transaction_type_name", value_col)
  missing_tx <- setdiff(req_tx, names(tx))
  if (length(missing_tx) > 0) {
    stop("Missing required columns in iati::dataTransaction: ", paste(missing_tx, collapse = ", "))
  }
  if (!("iati_identifier" %in% names(act))) stop("Missing `iati_identifier` in iati::dataActivity.")

  # ---- 1) Join + parse dates robustly ----
  df <- tx |>
    dplyr::left_join(act, by = "iati_identifier") |>
    dplyr::filter(.data$transaction_type_name == "Incoming Commitment") |>
    dplyr::mutate(
      tx_date = as.Date(
        lubridate::parse_date_time(
          .data$transaction_date,
          orders = c("ymd", "Ymd", "ymd HMS", "Ymd HMS", "ymd HM", "Ymd HM", "dmy", "mdy"),
          quiet = TRUE,
          tz = "UTC"
        )
      ),
      year_tx  = lubridate::year(.data$tx_date),
      tx_value = as.numeric(.data[[value_col]])
    ) |>
    dplyr::filter(!is.na(.data$tx_date), !is.na(.data$year_tx), !is.na(.data$tx_value))

  # ---- 2) Optional filters (vector-friendly + safe) ----
  year_filter      <- year
  programme_filter <- programme_lab
  ops_filter       <- iati_identifier_ops
  country_filter   <- ctr_name

  if (!is.null(year_filter)) {
    df <- df |> dplyr::filter(.data$year_tx %in% .env$year_filter)
  }
  if (!is.null(programme_filter)) {
    if (!("programme_lab" %in% names(df))) stop("`programme_lab` column not found in joined data.")
    df <- df |> dplyr::filter(.data$programme_lab %in% .env$programme_filter)
  } else if (!is.null(ops_filter)) {
    if (!("iati_identifier_ops" %in% names(df))) stop("`iati_identifier_ops` column not found in joined data.")
    df <- df |> dplyr::filter(.data$iati_identifier_ops %in% .env$ops_filter)
  } else if (!is.null(country_filter)) {
    if (!("ctr_name" %in% names(df))) stop("`ctr_name` column not found in joined data.")
    df <- df |> dplyr::filter(.data$ctr_name %in% .env$country_filter)
  }

  if (nrow(df) == 0) stop("No data available after filtering.")

  # ---- 3) Split donor vs others ----
  donor_df <- df |> dplyr::filter(.data$transaction_provider_org == donor_name)
  if (nrow(donor_df) == 0) stop("Donor '", donor_name, "' not found under current filters.")
  others_df <- df |> dplyr::filter(.data$transaction_provider_org != donor_name)

  # ---- 4) Apply top_n_donors filter to comparator if specified ----
  if (!is.null(top_n_donors)) {
    if (!is.numeric(top_n_donors) || top_n_donors < 1) {
      stop("top_n_donors must be a positive integer.")
    }
    
    # Calculate total funding per donor across all filtered years
    other_donor_totals <- others_df |>
      dplyr::group_by(.data$transaction_provider_org) |>
      dplyr::summarise(
        total_funding = sum(.data$tx_value, na.rm = TRUE),
        .groups = "drop"
      ) |>
      dplyr::arrange(dplyr::desc(.data$total_funding)) |>
      dplyr::slice(1:top_n_donors)
    
    # Keep only top N donors for comparator
    top_comparator_donors <- other_donor_totals$transaction_provider_org
    
    # Filter others_df to include only top donors
    others_df <- others_df |>
      dplyr::filter(.data$transaction_provider_org %in% top_comparator_donors)
    
    if (verbose) {
      message("Restricting comparator to top ", top_n_donors, 
              " other donors by total funding. Comparator donors: ",
              paste(top_comparator_donors, collapse = ", "))
    }
  }

  # ---- 5) Define time bucket ----
  bucket_unit <- if (time_unit == "month") "month" else "quarter"
  donor_df  <- donor_df  |> dplyr::mutate(period = lubridate::floor_date(.data$tx_date, unit = bucket_unit))
  others_df <- others_df |> dplyr::mutate(period = lubridate::floor_date(.data$tx_date, unit = bucket_unit))

  # ---- 6) Donor period summaries ----
  donor_period <- donor_df |>
    dplyr::group_by(.data$period) |>
    dplyr::summarise(
      donor_total = sum(.data$tx_value, na.rm = TRUE),
      donor_n     = dplyr::n(),
      donor_mean  = donor_total / donor_n,
      .groups = "drop"
    )

  # ---- 7) Weighted "other donors" period mean ----
  # Only calculate if there are other donors to compare with
  others_period <- NULL
  others_label <- "Other donors"
  
  if (nrow(others_df) > 0) {
    others_totals <- others_df |>
      dplyr::group_by(.data$transaction_provider_org) |>
      dplyr::summarise(donor_total_all = sum(.data$tx_value, na.rm = TRUE), .groups = "drop") |>
      dplyr::filter(.data$donor_total_all > 0) |>
      dplyr::mutate(weight = .data$donor_total_all / sum(.data$donor_total_all, na.rm = TRUE))

    others_period_donor <- others_df |>
      dplyr::group_by(.data$transaction_provider_org, .data$period) |>
      dplyr::summarise(
        total = sum(.data$tx_value, na.rm = TRUE),
        n     = dplyr::n(),
        mean  = total / n,
        .groups = "drop"
      ) |>
      dplyr::left_join(
        others_totals |> dplyr::select(transaction_provider_org, weight),
        by = "transaction_provider_org"
      )

    others_period <- others_period_donor |>
      dplyr::group_by(.data$period) |>
      dplyr::summarise(
        others_weighted_mean = sum(.data$mean * .data$weight, na.rm = TRUE),
        .groups = "drop"
      )
    
    # Update label for comparator
    if (!is.null(top_n_donors)) {
      others_label <- paste0("Top ", top_n_donors, " other donors")
    }
  }

  # ---- 8) Forecast donor trend (lm on log1p of donor_mean) ----
  donor_period_model <- donor_period |>
    dplyr::arrange(.data$period) |>
    dplyr::mutate(t = dplyr::row_number())

  forecast_df <- NULL
  if (nrow(donor_period_model) >= 4 && forecast_horizon > 0) {

    fit <- stats::lm(log1p(donor_mean) ~ t, data = donor_period_model)

    last_period <- max(donor_period_model$period)

    # âœ… No %m+%: use seq.Date (robust, base R)
    step_months <- if (time_unit == "month") 1 else 3
    future_periods <- seq.Date(
      from = last_period,
      by   = paste(step_months, "months"),
      length.out = forecast_horizon + 1
    )[-1]

    future_t <- max(donor_period_model$t) + seq_len(forecast_horizon)

    if (show_forecast_ci) {
      pred_ci <- stats::predict(fit, newdata = data.frame(t = future_t), interval = "confidence")
    
      # guard: ensure we can access columns by name
      pred_ci <- as.data.frame(pred_ci)
    
      forecast_df <- dplyr::tibble(
        period = future_periods,
        pred = expm1(pred_ci$fit),
        lwr  = expm1(pred_ci$lwr),
        upr  = expm1(pred_ci$upr)
      )
    } else {
      pred <- stats::predict(fit, newdata = data.frame(t = future_t))
      forecast_df <- dplyr::tibble(
        period = future_periods,
        pred = expm1(as.numeric(pred))
      )
    }

  }

  # ---- 9) KPI text for title/subtitle ----
  donor_avg_txn <- mean(donor_df$tx_value, na.rm = TRUE)
  donor_n_txn   <- nrow(donor_df)
  donor_years   <- length(unique(donor_df$year_tx))
  donor_txn_per_year <- donor_n_txn / max(donor_years, 1)

  # Calculate comparator KPIs if comparator exists
  others_weighted_avg_txn <- NA
  others_weighted_txn_per_year <- NA
  comparator_available <- FALSE
  
  if (!is.null(others_period) && nrow(others_df) > 0) {
    comparator_available <- TRUE
    
    # Calculate weighted average transactions per year for other donors
    others_kpi <- others_df |>
      dplyr::group_by(.data$transaction_provider_org) |>
      dplyr::summarise(
        total = sum(.data$tx_value, na.rm = TRUE),
        n = dplyr::n(),
        avg_txn = total / n,
        years = dplyr::n_distinct(.data$year_tx),
        txn_per_year = n / pmax(years, 1),
        .groups = "drop"
      ) |>
      dplyr::filter(.data$total > 0) |>
      dplyr::mutate(w = .data$total / sum(.data$total, na.rm = TRUE))

    others_weighted_avg_txn <- sum(others_kpi$avg_txn * others_kpi$w, na.rm = TRUE)
    others_weighted_txn_per_year <- sum(others_kpi$txn_per_year * others_kpi$w, na.rm = TRUE)
  }

  fmt_money <- scales::label_number(scale_cut = scales::cut_short_scale(), accuracy = 0.1)
  fmt_num   <- scales::label_number(accuracy = 0.1)

  title <- paste0("Funding Volatility for ", donor_name,  " (",
      fmt_money(donor_avg_txn),  "$ Average Transaction Amount through ", 
      fmt_num(donor_txn_per_year), " Avg. # of Transactions/Year). ",
    if (!is.null(country_filter)) paste0("| Commitments to  ", paste(country_filter, collapse = ", ")) else "")
  
  # Build subtitle based on comparator availability
  if (comparator_available) {
    subtitle <- paste0(
      fmt_money(donor_avg_txn),  "$ Average Transaction Amount through ", 
      fmt_num(donor_txn_per_year), " Avg. Transactions per Year  (Benchmark ", 
      others_label, ":  ", fmt_money(others_weighted_avg_txn),
      "$ Average Transaction Amount through ", fmt_num(others_weighted_txn_per_year), " Avg. Transactions per Year)"
    )
  } else {
    subtitle <- paste0(
      fmt_money(donor_avg_txn),  "$ Average Transaction Amount through ", 
      fmt_num(donor_txn_per_year), " Avg. Transactions per Year  (No comparator data available)"
    )
  }

  # ---- 10) Plot ----
  col_donor    <- "#0072BC"
  col_others   <- "#6B6E70"
  col_forecast <- "#F28E2B"

  p <- ggplot2::ggplot() +
    # Selected donor: individual transaction points
    ggplot2::geom_point(
      data = donor_df,
      ggplot2::aes(x = .data$tx_date, y = .data$tx_value),
      color = col_donor,
      alpha = 0.25,
      size = 1.5
    ) +
    # Selected donor: period mean line
    ggplot2::geom_line(
      data = donor_period,
      ggplot2::aes(x = .data$period, y = .data$donor_mean),
      color = col_donor,
      linewidth = 1
    ) +
    # Selected donor: smoothed trend line
    ggplot2::geom_smooth(
      data = donor_period,
      ggplot2::aes(x = .data$period, y = .data$donor_mean),
      method  = if (smooth_method == "loess") "loess" else "gam",
      formula = if (smooth_method == "loess") y ~ x else y ~ s(x, bs = "cs"),
      se = FALSE,
      color = col_donor,
      linewidth = 1,
      linetype = "solid",
      alpha = 0.15
    ) +
    # Other donors: weighted mean trend line (NO individual points)
    { if (!is.null(others_period) && nrow(others_period) > 0)
      ggplot2::geom_line(
        data = others_period,
        ggplot2::aes(x = .data$period, y = .data$others_weighted_mean),
        color = col_others,
        linewidth = 1,
        linetype = "dotdash"
      )
    } +
    { if (!is.null(forecast_df) && show_forecast_ci)
      ggplot2::geom_ribbon(
        data = forecast_df,
        ggplot2::aes(x = .data$period, ymin = .data$lwr, ymax = .data$upr),
        fill = col_forecast,
        alpha = 0.15
      )
    } +
    { if (!is.null(forecast_df))
      ggplot2::geom_line(
        data = forecast_df,
        ggplot2::aes(x = .data$period, y = .data$pred),
        color = col_forecast,
        linewidth = 1,
        linetype = "dashed"
      )
    } +
    ggplot2::scale_y_continuous(labels = scales::label_number(scale_cut = scales::cut_short_scale())) +
    ggplot2::labs(
      title = title,
      subtitle = subtitle,
      x = "Transaction date",
      y = "Transaction value (USD)",
      caption = paste0(
        "Blue points: donor transactions. Blue line: donor period mean (", time_unit,
        "). Grey dashed line: weighted ", tolower(others_label), " mean. ",
        if (!is.null(forecast_df)) "Dashed orange: simple trend forecast. " else "",
        "\nSource: Data published by UNHCR as part of the International Aid Transparency Initiative (IATI)"
      )     
    ) +
    unhcrthemes::theme_unhcr(grid = "Y", axis = "X", axis_title = "X", font_size = 18)

  if (verbose) {
    message(
      "Volatility plot prepared for donor: ", donor_name,
      " | periods: ", nrow(donor_period),
      " | comparator: ", ifelse(is.null(others_period) || nrow(others_period) == 0, "none", others_label),
      " | forecast: ", ifelse(is.null(forecast_df), "none", paste0(nrow(forecast_df), " periods"))
    )
  }

  p
}
